<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MR GAMES+ Undertale Game</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:black; font-family: 'Courier New', monospace; }
  canvas { display:block; margin:0 auto; background:#000; }
  #ui { position:absolute; top:10px; left:10px; color:white; font-size:18px; }
  #menu { position:absolute; top:0; left:0; width:100%; height:100%; background:#111; display:flex; align-items:center; justify-content:center; flex-direction:column; }
  .menu-button { padding:15px 30px; margin:10px; border:2px solid white; cursor:pointer; color:white; font-size:24px; }
  .menu-button:hover { background:white; color:black; }
</style>
</head>
<body>
<div id="menu">
  <h1 style="color:white; font-size:48px;">MR GAMES+ UNDERTALE</h1>
  <div class="menu-button" onclick="startGame()">Start Game</div>
  <div class="menu-button" onclick="loadGame()">Continue</div>
  <div class="menu-button" onclick="resetGame()">Reset Save</div>
</div>
<div id="ui"></div>
<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const ui = document.getElementById('ui');
let gameState = 'menu'; // menu, fight, dialogue
let level = 1;
let player = { x:400, y:500, w:32, h:32, speed:5, hp:20, maxHp:20, dash:0, dashMax:3, dashCooldown:0 };
let bullets = [];
let enemies = [];
let dialogueQueue = [];
let saveData = JSON.parse(localStorage.getItem('mrGamesSave')) || {level:1, hp:20, upgrades:[]};

function startGame() {
    document.getElementById('menu').style.display = 'none';
    loadLevel(saveData.level);
}
function loadGame() {
    if(saveData.level) {
        document.getElementById('menu').style.display = 'none';
        player.hp = saveData.hp;
        loadLevel(saveData.level);
    } else alert("No save found!");
}
function resetGame() {
    localStorage.removeItem('mrGamesSave');
    alert("Save reset!");
}

function saveGame() {
    saveData.level = level;
    saveData.hp = player.hp;
    localStorage.setItem('mrGamesSave', JSON.stringify(saveData));
}

// Utility
function clamp(val, min, max){ return Math.max(min, Math.min(max, val)); }
function rand(min,max){ return Math.random()*(max-min)+min; }
function distance(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

// Input
let keys = {};
document.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
document.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

// Bullets
function spawnBullet(x,y,vx,vy,color='white',size=8){ bullets.push({x,y,vx,vy,color,size}); }

// Enemies
function spawnEnemy(x,y,hp,pattern,name){ enemies.push({x,y,hp,maxHp:hp,pattern,name,timer:0}); }

// Level Loader
function loadLevel(lv) {
    bullets = [];
    enemies = [];
    level = lv;
    switch(lv){
        case 1:
            spawnEnemy(400,100,15,'basic','Dummy');
            dialogueQueue.push("A Dummy appears!");
            break;
        case 2:
            spawnEnemy(400,100,25,'arc','Fallen Hero');
            dialogueQueue.push("Fallen Hero wants to fight!");
            break;
        case 3:
            spawnEnemy(400,100,30,'spiral','Mad Scientist');
            dialogueQueue.push("Mad Scientist attacks!");
            break;
        case 4:
            spawnEnemy(400,100,40,'rain','Ice Queen');
            dialogueQueue.push("Ice Queen descends!");
            break;
        case 5:
            spawnEnemy(400,100,50,'multi','King of Chaos');
            dialogueQueue.push("The King of Chaos challenges you!");
            break;
    }
    gameState='dialogue';
}

// Dialogue System
function nextDialogue() {
    if(dialogueQueue.length>0) dialogueQueue.shift();
    else gameState='fight';
}

// Game Loop
function update() {
    if(gameState==='fight'){
        // Player Movement
        if(keys['arrowleft']||keys['a']) player.x-=player.speed;
        if(keys['arrowright']||keys['d']) player.x+=player.speed;
        if(keys['arrowup']||keys['w']) player.y-=player.speed;
        if(keys['arrowdown']||keys['s']) player.y+=player.speed;
        player.x = clamp(player.x,0,canvas.width-player.w);
        player.y = clamp(player.y,0,canvas.height-player.h);
        
        // Dash mechanic
        if(keys[' '] && player.dashCooldown<=0 && player.dash<player.dashMax){
            player.dash+=1;
            player.dashCooldown=60;
            // temporary speed boost
            player.x += (keys['arrowright']?-1:0)*50;
            player.x -= (keys['arrowleft']?-1:0)*50;
            player.y += (keys['arrowdown']?-1:0)*50;
            player.y -= (keys['arrowup']?-1:0)*50;
        }
        if(player.dashCooldown>0) player.dashCooldown--;

        // Enemy attacks
        enemies.forEach(e=>{
            e.timer++;
            if(e.pattern==='basic' && e.timer%60===0) spawnBullet(e.x,e.y,0,3,'red',10);
            if(e.pattern==='arc' && e.timer%120===0){
                for(let a=-60;a<=60;a+=15){
                    let rad = a*Math.PI/180;
                    spawnBullet(e.x,e.y,3*Math.sin(rad),3*Math.cos(rad),'orange',8);
                }
            }
            if(e.pattern==='spiral' && e.timer%5===0){
                let angle = e.timer*0.1;
                spawnBullet(e.x,e.y,3*Math.cos(angle),3*Math.sin(angle),'purple',6);
            }
            if(e.pattern==='rain' && e.timer%20===0){
                spawnBullet(rand(0,canvas.width),0,0,4,'cyan',6);
            }
            if(e.pattern==='multi' && e.timer%80===0){
                for(let a=0;a<360;a+=30){
                    let rad = a*Math.PI/180;
                    spawnBullet(e.x,e.y,4*Math.cos(rad),4*Math.sin(rad),'yellow',7);
                }
            }
        });

        // Bullets update
        bullets.forEach(b=>{
            b.x+=b.vx;
            b.y+=b.vy;
            if(b.x<0||b.x>canvas.width||b.y<0||b.y>canvas.height) b.dead=true;
            if(b.x+ b.size>player.x && b.x<player.x+player.w && b.y+ b.size>player.y && b.y<player.y+player.h){
                player.hp--;
                b.dead=true;
            }
        });
        bullets = bullets.filter(b=>!b.dead);

        // Check enemies dead
        enemies = enemies.filter(e=>{
            if(e.hp<=0) { levelUp(); return false; }
            return true;
        });
    }
}

function levelUp(){
    dialogueQueue.push("You defeated the enemy!");
    level++;
    saveGame();
    loadLevel(level>5?1:level); // loop for testing
}

// Draw
function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // Background
    ctx.fillStyle='black';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    if(gameState==='dialogue'){
        ctx.fillStyle='white';
        ctx.font='24px Courier New';
        ctx.fillText(dialogueQueue[0] || '', 50, 550);
    }
    if(gameState==='fight'){
        // Player
        ctx.fillStyle='green';
        ctx.fillRect(player.x,player.y,player.w,player.h);

        // Bullets
        bullets.forEach(b=>{
            ctx.fillStyle=b.color;
            ctx.beginPath();
            ctx.arc(b.x,b.y,b.size,0,Math.PI*2);
            ctx.fill();
        });

        // Enemies
        enemies.forEach(e=>{
            ctx.fillStyle='red';
            ctx.fillRect(e.x-20,e.y-20,40,40);
            // HP Bar
            ctx.fillStyle='white';
            ctx.fillRect(e.x-25,e.y-30,50,5);
            ctx.fillStyle='red';
            ctx.fillRect(e.x-25,e.y-30,50*(e.hp/e.maxHp),5);
        });

        // UI
        ui.innerHTML = `HP: ${player.hp}/${player.maxHp} | Dash: ${player.dash}/${player.dashMax}`;
    }
}

canvas.addEventListener('click', ()=>{ if(gameState==='dialogue') nextDialogue(); });

function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
}

loop();
</script>// ================== PART 2: Boss Phases & Level Enhancements ==================

// Dynamic Backgrounds
function drawBackground() {
    switch(level){
        case 1: ctx.fillStyle='black'; break;
        case 2: ctx.fillStyle='darkred'; break;
        case 3: ctx.fillStyle='darkblue'; break;
        case 4: ctx.fillStyle='darkcyan'; break;
        case 5: 
            // Animated chaos background
            for(let i=0;i<50;i++){
                ctx.fillStyle=`hsl(${(Date.now()/10+i*7)%360},50%,50%)`;
                ctx.fillRect(rand(0,canvas.width),rand(0,canvas.height),rand(2,6),rand(2,6));
            }
            return;
        default: ctx.fillStyle='black';
    }
    ctx.fillRect(0,0,canvas.width,canvas.height);
}

// Boss AI Phases
function bossAI(e){
    if(!e.phase) e.phase = 1;

    e.timer++;

    switch(e.name){
        case 'Dummy':
            if(e.hp<e.maxHp/2) e.pattern='arc';
            break;
        case 'Fallen Hero':
            if(e.hp<e.maxHp*0.7) e.pattern='spiral';
            if(e.hp<e.maxHp*0.3) e.pattern='multi';
            break;
        case 'Mad Scientist':
            if(e.hp<e.maxHp*0.5 && e.phase===1){ e.phase=2; e.timer=0; dialogueQueue.push("Mad Scientist enrages!"); }
            break;
        case 'Ice Queen':
            if(e.hp<e.maxHp*0.6 && e.phase===1){ e.phase=2; e.timer=0; e.pattern='multi'; dialogueQueue.push("Ice Queen summons blizzard!"); }
            break;
        case 'King of Chaos':
            if(e.hp<e.maxHp*0.75 && e.phase===1){ e.phase=2; e.timer=0; dialogueQueue.push("King of Chaos unleashes madness!"); }
            if(e.hp<e.maxHp*0.4 && e.phase===2){ e.phase=3; e.timer=0; e.pattern='multi'; }
            break;
    }
}

// Level Rewards
function levelReward(){
    if(level===1) { player.maxHp += 5; player.hp+=5; dialogueQueue.push("You gained +5 HP!"); }
    if(level===2) { player.maxHp += 5; player.hp+=5; dialogueQueue.push("You gained +5 HP!"); }
    if(level===3) { player.maxHp += 10; player.hp+=10; dialogueQueue.push("You gained +10 HP!"); }
    if(level===4) { player.maxHp += 10; player.hp+=10; dialogueQueue.push("You gained +10 HP!"); }
    if(level===5) { player.maxHp += 20; player.hp+=20; dialogueQueue.push("You gained +20 HP!"); }
}

// Enhanced Enemy Attack Patterns
function enhancedEnemyAttack(e){
    // random bullets
    if(e.pattern==='multi' && e.timer%50===0){
        for(let a=0;a<360;a+=20){
            let rad = a*Math.PI/180;
            spawnBullet(e.x,e.y,5*Math.cos(rad),5*Math.sin(rad),'magenta',7);
        }
    }
    // occasional homing bullets
    if(e.pattern==='spiral' && e.timer%60===0){
        let angle = Math.atan2(player.y - e.y, player.x - e.x);
        spawnBullet(e.x,e.y,4*Math.cos(angle),4*Math.sin(angle),'lime',6);
    }
}

// Update Function Extension
const oldUpdate = update;
update = function(){
    oldUpdate(); // Keep all original updates

    // Boss AI & enhanced attacks
    enemies.forEach(e=>{
        bossAI(e);
        enhancedEnemyAttack(e);
    });

    // Regenerate dash over time
    if(player.dashCooldown===0 && player.dash>0) player.dash--;
}

// Draw Function Extension
const oldDraw = draw;
draw = function(){
    drawBackground(); // Draw dynamic backgrounds first
    oldDraw();        // Then draw everything else

    // Optional: show phase for bosses
    enemies.forEach(e=>{
        if(e.phase) {
            ctx.fillStyle='white';
            ctx.font='16px Courier New';
            ctx.fillText(`Phase: ${e.phase}`, e.x-20, e.y-40);
        }
    });
}

// Overwrite levelUp to add rewards and dialogue
levelUp = function(){
    dialogueQueue.push("You defeated the enemy!");
    levelReward(); // give bonuses
    saveGame();
    level++;
    if(level>5){
        dialogueQueue.push("Congratulations! You beat all levels!");
        level=1; // loop for replay
    }
    loadLevel(level);
}
 // ================== PART 3: Dialogue, Combat, Menu, & Polish ==================

// Dialogue System
let dialogueQueue = [];
let dialogueActive = false;
function drawDialogue(){
    if(dialogueQueue.length>0){
        dialogueActive=true;
        ctx.fillStyle='rgba(0,0,0,0.7)';
        ctx.fillRect(50, canvas.height-120, canvas.width-100, 80);
        ctx.fillStyle='white';
        ctx.font='18px Courier New';
        let text = dialogueQueue[0];
        wrapText(ctx, text, 60, canvas.height-90, canvas.width-120, 22);
    } else dialogueActive=false;
}

function nextDialogue(){
    if(dialogueQueue.length>0) dialogueQueue.shift();
}

// Text wrapping helper
function wrapText(ctx, text, x, y, maxWidth, lineHeight){
    let words = text.split(' ');
    let line = '';
    for(let n=0;n<words.length;n++){
        let testLine = line + words[n] + ' ';
        let metrics = ctx.measureText(testLine);
        if(metrics.width > maxWidth && n>0){
            ctx.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        } else line = testLine;
    }
    ctx.fillText(line, x, y);
}

// Player Attack/Defend
function playerAttack(){
    if(!dialogueActive){
        let target = enemies[0]; // single enemy for simplicity
        if(target){
            let dmg = rand(5,15);
            target.hp -= dmg;
            dialogueQueue.push(`You dealt ${dmg} damage!`);
            if(target.hp<=0){
                dialogueQueue.push(`${target.name} defeated!`);
                levelUp();
            }
        }
    }
}

function playerDefend(){
    if(!dialogueActive){
        dialogueQueue.push("You brace for the next attack!");
        player.defending=true;
        setTimeout(()=>{player.defending=false}, 1000);
    }
}

// Menu System
let inMenu = false;
function drawMenu(){
    if(inMenu){
        ctx.fillStyle='rgba(0,0,0,0.8)';
        ctx.fillRect(50,50,200,150);
        ctx.fillStyle='white';
        ctx.font='20px Courier New';
        ctx.fillText("MENU", 90, 80);
        ctx.fillText("1. Attack", 60, 110);
        ctx.fillText("2. Defend", 60, 140);
        ctx.fillText("3. Save", 60, 170);
    }
}

// Menu Input
document.addEventListener('keydown', function(e){
    if(inMenu && !dialogueActive){
        switch(e.key){
            case '1': playerAttack(); break;
            case '2': playerDefend(); break;
            case '3': saveGame(); dialogueQueue.push("Game Saved!"); break;
        }
    }
    if(e.key==='Enter' && dialogueActive){
        nextDialogue();
    }
    if(e.key==='Escape'){
        inMenu = !inMenu;
    }
});

// Simple Sound Effects
function playSound(type){
    const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    switch(type){
        case 'attack': oscillator.frequency.value = 400; break;
        case 'defend': oscillator.frequency.value = 200; break;
        case 'levelup': oscillator.frequency.value = 600; break;
        default: oscillator.frequency.value = 300;
    }
    oscillator.type='square';
    oscillator.start();
    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.2);
}

// Particle Effects for attacks
let particles = [];
function spawnParticles(x,y,color){
    for(let i=0;i<10;i++){
        particles.push({
            x, y,
            vx: rand(-2,2),
            vy: rand(-2,2),
            life: rand(20,50),
            color
        });
    }
}

function drawParticles(){
    particles.forEach((p,i)=>{
        ctx.fillStyle=p.color;
        ctx.fillRect(p.x,p.y,2,2);
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if(p.life<=0) particles.splice(i,1);
    });
}

// Extend attack/defend with particles & sound
function playerAttack(){
    if(!dialogueActive){
        let target = enemies[0];
        if(target){
            let dmg = rand(5,15);
            target.hp -= dmg;
            spawnParticles(target.x, target.y,'yellow');
            playSound('attack');
            dialogueQueue.push(`You dealt ${dmg} damage!`);
            if(target.hp<=0){
                dialogueQueue.push(`${target.name} defeated!`);
                playSound('levelup');
                levelUp();
            }
        }
    }
}

function playerDefend(){
    if(!dialogueActive){
        dialogueQueue.push("You brace for the next attack!");
        player.defending=true;
        spawnParticles(player.x, player.y,'cyan');
        playSound('defend');
        setTimeout(()=>{player.defending=false}, 1000);
    }
}

// ================== MAIN LOOP EXTENSIONS ==================
const oldMainLoop = mainLoop;
mainLoop = function(){
    oldMainLoop();
    drawDialogue();
    drawMenu();
    drawParticles();
}

// ================== HELPER FUNCTIONS ==================
function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

// ================== AUTO SAVE ON START ==================
loadGame();     

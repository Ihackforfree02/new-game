<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Undertale/Deltarune Inspired Game</title>
<style>
  body { margin:0; background:#000; color:#fff; font-family:sans-serif; overflow:hidden; }
  canvas { display:block; margin:0 auto; background:#111; }
  #ui { position:absolute; top:10px; left:50%; transform:translateX(-50%); color:#fff; text-align:center; font-family:sans-serif; }
  #messages { margin-top:10px; height:60px; overflow-y:auto; font-size:14px; }
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<div id="ui">
  <div>HP: <span id="hp">100</span> | Burst: <span id="burst">0%</span> | Night: <span id="night">1</span></div>
  <div id="messages"></div>
</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- Game Settings ---
let keybinds = JSON.parse(localStorage.getItem('keybinds')) || {up:'ArrowUp', down:'ArrowDown', left:'ArrowLeft', right:'ArrowRight', burst:'q'};
const box = {x:150, y:100, width:500, height:400};
let player = {x: box.x+box.width/2, y: box.y+box.height/2, size:20, hp:100, burst:0, burstActive:false};
let bullets = [];
let bosses = [];
let currentBossIndex = 0;
let night = 1;
let messages = [];
let lastTime = 0;

// --- Utility Functions ---
function addMessage(msg){
  messages.push(msg);
  if(messages.length>5) messages.shift();
  document.getElementById('messages').innerText = messages.join('\n');
}

function random(min,max){ return Math.random()*(max-min)+min; }
function clamp(val,min,max){ return Math.max(min, Math.min(max,val)); }

// --- Boss Definitions ---
class Boss {
  constructor(name,color,hp,attacks){
    this.name=name; this.color=color; this.hp=hp; this.maxHp=hp; this.attacks=attacks; this.attackIndex=0; this.timer=0;
  }
  getCurrentAttack(){ return this.attacks[this.attackIndex]; }
  nextAttack(){ this.attackIndex = (this.attackIndex+1)%this.attacks.length; this.timer=0; }
}

// Example attacks
function createBosses(){
  bosses = [
    new Boss("Redfang","#ff5555",50,[
      {type:"spread",count:8,speed:2,interval:1},
      {type:"homing",count:1,speed:3,interval:2}
    ]),
    new Boss("Blazewing","#ffaa00",80,[
      {type:"circle",count:12,speed:2,interval:1},
      {type:"stopmove",duration:1.5}
    ]),
    new Boss("Frostbite","#55ffff",100,[
      {type:"zigzag",count:10,speed:2.5,interval:1.2},
      {type:"homing",count:2,speed:3,interval:2}
    ]),
    // Add more bosses up to 20...
    new Boss("Radiance","#ffffaa",300,[
      {type:"radiance",count:20,speed:3,interval:0.5},
      {type:"homing",count:5,speed:3.5,interval:1},
      {type:"stopmove",duration:1}
    ])
  ];
}

// --- Bullet Mechanics ---
class Bullet {
  constructor(x,y,vx,vy,color,size=8){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.color=color; this.size=size; }
  update(dt){
    this.x += this.vx*dt;
    this.y += this.vy*dt;
  }
  draw(){
    ctx.fillStyle=this.color;
    ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill();
  }
}

// --- Input ---
let keys = {};
document.addEventListener('keydown',e=>{ keys[e.key]=true; });
document.addEventListener('keyup',e=>{ keys[e.key]=false; });

// --- Player Movement ---
function updatePlayer(dt){
  let speed = 200;
  if(keys[keybinds.up]) player.y -= speed*dt;
  if(keys[keybinds.down]) player.y += speed*dt;
  if(keys[keybinds.left]) player.x -= speed*dt;
  if(keys[keybinds.right]) player.x += speed*dt;
  player.x = clamp(player.x, box.x+player.size, box.x+box.width-player.size);
  player.y = clamp(player.y, box.y+player.size, box.y+box.height-player.size);

  // Burst
  if(keys[keybinds.burst] && player.burst>=100 && !player.burstActive){
    player.burstActive = true; player.burst=0; addMessage("BURST ACTIVATED!");
    setTimeout(()=>{ player.burstActive=false; addMessage("Burst ended"); },3000);
  }
  if(!player.burstActive && player.burst<100) player.burst += dt*10;
  document.getElementById('hp').innerText = player.hp;
  document.getElementById('burst').innerText = Math.floor(player.burst);
}

// --- Boss AI & Attack Patterns ---
function spawnBullets(boss,dt){
  boss.timer += dt;
  let atk = boss.getCurrentAttack();
  if(!atk) return;

  if(!atk.lastSpawn) atk.lastSpawn=0;
  if(boss.timer - atk.lastSpawn >= (atk.interval||1)){
    atk.lastSpawn = boss.timer;
    if(atk.type==="spread"){
      for(let i=0;i<atk.count;i++){
        let angle = (i/atk.count)*Math.PI*2;
        bullets.push(new Bullet(box.x+box.width/2,box.y+50, Math.cos(angle)*atk.speed, Math.sin(angle)*atk.speed, boss.color));
      }
    } else if(atk.type==="circle"){
      for(let i=0;i<atk.count;i++){
        let angle = (i/atk.count)*Math.PI*2;
        bullets.push(new Bullet(box.x+box.width/2,box.y+50, Math.cos(angle)*atk.speed, Math.sin(angle)*atk.speed, boss.color));
      }
    } else if(atk.type==="homing"){
      for(let i=0;i<atk.count;i++){
        let dx = player.x-(box.x+box.width/2);
        let dy = player.y-(box.y+50);
        let len = Math.hypot(dx,dy);
        bullets.push(new Bullet(box.x+box.width/2,box.y+50, dx/len*atk.speed, dy/len*atk.speed, boss.color));
      }
    } else if(atk.type==="zigzag"){
      for(let i=0;i<atk.count;i++){
        let angle = (i/atk.count)*Math.PI;
        bullets.push(new Bullet(box.x+box.width/2,box.y+50, Math.cos(angle)*atk.speed, Math.sin(angle*2)*atk.speed, boss.color));
      }
    } else if(atk.type==="radiance"){
      for(let i=0;i<atk.count;i++){
        let angle = (i/atk.count)*Math.PI*2 + boss.timer;
        bullets.push(new Bullet(box.x+box.width/2,box.y+50, Math.cos(angle)*atk.speed, Math.sin(angle)*atk.speed, boss.color));
      }
    } else if(atk.type==="stopmove"){
      atk.endTime = boss.timer + (atk.duration||1);
      bullets.forEach(b=>b.vx=b.vy=0);
    }
  }

  if(atk.type==="stopmove" && boss.timer>=atk.endTime){
    boss.nextAttack();
  }
}

// --- Update Bullets ---
function updateBullets(dt){
  bullets.forEach(b=>{
    if(!player.burstActive){
      let dx = b.x-player.x, dy=b.y-player.y;
      if(Math.hypot(dx,dy)<b.size+player.size){
        player.hp -= 10;
        addMessage("Ouch! -10 HP");
        b.toRemove=true;
      }
    }
    b.update(dt);
    if(b.x<0 || b.x>canvas.width || b.y<0 || b.y>canvas.height) b.toRemove=true;
  });
  bullets = bullets.filter(b=>!b.toRemove);
}

// --- Draw ---
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // Attack box
  ctx.strokeStyle="#fff"; ctx.lineWidth=3;
  ctx.strokeRect(box.x,box.y,box.width,box.height);

  // Player
  ctx.fillStyle="red";
  ctx.beginPath(); ctx.arc(player.x,player.y,player.size,0,Math.PI*2); ctx.fill();

  // Bullets
  bullets.forEach(b=>b.draw());

  // Boss info
  let boss = bosses[currentBossIndex];
  if(boss){
    ctx.fillStyle=boss.color;
    ctx.fillRect(600,50,150,20);
    ctx.fillStyle="#000"; ctx.fillRect(600,50,150*(1-boss.hp/boss.maxHp),20);
    ctx.fillStyle="#fff"; ctx.fillText(boss.name,600,45);
  }
}

// --- Game Loop ---
function loop(timestamp){
  let dt = (timestamp-lastTime)/1000;
  lastTime = timestamp;

  updatePlayer(dt);
  let boss = bosses[currentBossIndex];
  if(boss){
    spawnBullets(boss,dt);
    updateBullets(dt);
    if(boss.hp<=0){
      addMessage(`${boss.name} defeated!`);
      currentBossIndex++;
      night++;
      document.getElementById('night').innerText = night;
      if(currentBossIndex>=bosses.length){
        addMessage("All bosses defeated! You win!");
        cancelAnimationFrame(raf);
      }
    }
  }

  draw();
  raf = requestAnimationFrame(loop);
}

// --- Start Game ---
createBosses();
let raf = requestAnimationFrame(loop);
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Black Hole Starcatcher — Saved Progress & Rewards</title>
<style>
  :root{--ui-bg:rgba(8,10,20,0.6);--accent:#7be3ff;--muted:#cfeefc}
  html,body{height:100%;margin:0;background:radial-gradient(circle at 20% 10%, #071827 0%, #00010a 40%, #000 100%);font-family:Inter,Segoe UI,Arial,sans-serif;color:#fff;overflow:hidden;-webkit-tap-highlight-color:transparent}
  #uiTop{position:fixed;left:10px;right:10px;top:8px;display:flex;justify-content:space-between;gap:12px;z-index:40;align-items:center}
  #skinSelect{background:var(--ui-bg);padding:8px;border-radius:10px;display:flex;gap:8px;align-items:center;backdrop-filter:blur(6px)}
  .skin-btn{background:transparent;border:1px solid rgba(255,255,255,0.08);color:var(--muted);padding:6px 10px;border-radius:8px;font-weight:600;cursor:pointer}
  .skin-btn.active{border-color:var(--accent);color:var(--accent)}
  #scoreboard{background:var(--ui-bg);padding:8px 12px;border-radius:10px;display:flex;gap:12px;align-items:center;font-weight:700}
  #gameWrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
  canvas{display:block;max-width:100%;height:auto;border-radius:14px;box-shadow:0 12px 40px rgba(0,0,0,0.7)}
  #bottomUi{position:fixed;left:10px;right:10px;bottom:12px;display:flex;justify-content:center;gap:12px;z-index:40}
  #controls{background:var(--ui-bg);padding:8px;border-radius:10px;display:flex;gap:8px;align-items:center}
  .control-btn{background:transparent;border:1px solid rgba(255,255,255,0.08);padding:8px 12px;border-radius:8px;cursor:pointer;color:var(--muted);font-weight:700}
  #adminPanel{display:none;position:fixed;left:18px;top:70px;z-index:50;background:rgba(0,0,0,0.75);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);min-width:260px}
  #adminPanel h4{margin:0 0 8px 0;font-size:14px;color:var(--accent)}
  #adminPanel button, #adminPanel input[type=file]{display:block;width:100%;margin:6px 0;padding:8px;border-radius:8px;border:0;background:linear-gradient(90deg,#123 0%,#045 100%);color:#fff;font-weight:700;cursor:pointer}
  #accessoryList{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px}
  .acc-item{background:#0b1116;padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);display:flex;gap:6px;align-items:center}
  .acc-item img{width:36px;height:36px;object-fit:cover;border-radius:6px}
  #guideOverlay{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(2,6,12,0.95);padding:16px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);max-width:92%;z-index:60}
  #guideOverlay h3{margin:0 0 8px 0;color:var(--accent)}
  #rewardToast{position:fixed;left:50%;transform:translateX(-50%);top:14%;background:linear-gradient(90deg,#0b2030,#022);padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);color:#fff;display:none;z-index:70}
  #gameOverOverlay{display:none;position:fixed;inset:0;align-items:center;justify-content:center;background:linear-gradient(0deg, rgba(0,0,0,0.6), rgba(0,0,0,0.2));z-index:60}
  #gameOverCard{background:rgba(6,8,12,0.95);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);text-align:center}
  @media (max-width:600px){#skinSelect{font-size:13px}.skin-btn{padding:6px 8px}#scoreboard{font-size:13px}}
</style>
</head>
<body>
  <div id="uiTop">
    <div id="skinSelect" role="tablist" aria-label="Black hole skins">
      <span style="opacity:0.9;margin-right:6px">Skin:</span>
      <button class="skin-btn active" data-skin="classic">Classic</button>
      <button class="skin-btn" data-skin="neon">Neon</button>
      <button class="skin-btn" data-skin="ancient">Ancient</button>
    </div>
    <div id="scoreboard" aria-live="polite">
      Score: <strong id="sc">0</strong> • Lives: <strong id="lv">3</strong> • Level: <strong id="lvn">1</strong> • Best Level: <strong id="best">0</strong>
    </div>
  </div>

  <div id="gameWrap">
    <canvas id="gameCanvas" width="720" height="960" role="img" aria-label="Black Hole Starcatcher canvas"></canvas>
  </div>

  <div id="bottomUi">
    <div id="controls">
      <button id="btnLeft" class="control-btn" aria-label="Move left">◀</button>
      <button id="btnCenter" class="control-btn" aria-label="Center">▲</button>
      <button id="btnRight" class="control-btn" aria-label="Move right">▶</button>
    </div>
  </div>

  <div id="adminPanel" aria-hidden="true">
    <h4>Admin Panel</h4>
    <button id="giveLives">Give +5 Lives</button>
    <button id="skipWave">Skip Wave</button>
    <label style="color:#ddd;font-size:13px;margin-top:8px">Upload accessory image (PNG/JPG):</label>
    <input id="accessoryUpload" type="file" accept="image/*" />
    <div style="font-size:13px;color:#cfdff0;margin-top:6px">Accessories (toggle to equip):</div>
    <div id="accessoryList"></div>
    <label style="color:#ddd;font-size:13px;margin-top:8px">Accessory position:</label>
    <select id="accPosition" style="width:100%;padding:8px;border-radius:8px;margin-top:6px">
      <option value="top">Top</option>
      <option value="left">Left</option>
      <option value="right">Right</option>
      <option value="front">Front (center)</option>
    </select>
    <button id="hideAdmin" style="background:#333;margin-top:8px">Hide Admin</button>
  </div>

  <div id="guideOverlay">
    <h3>How to play</h3>
    <p>Control a black hole avatar that pulls in nearby stars. Move to collect falling stars and upgrades while avoiding enemies. Equip skins and accessories from the Admin Panel.</p>
    <ul>
      <li>Desktop: Arrow keys or A/D to move</li>
      <li>Mobile: Drag your finger or use on-screen buttons</li>
      <li>Hidden Admin: type "67" three times to open Admin Panel</li>
    </ul>
    <div style="text-align:center;margin-top:8px">
      <button id="closeGuide" style="padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:#012;font-weight:800;cursor:pointer">Start Playing</button>
    </div>
  </div>

  <div id="rewardToast"></div>

  <div id="gameOverOverlay" style="display:flex">
    <div id="gameOverCard">
      <h2 id="overTitle" style="margin:0 0 6px">Game Over</h2>
      <p id="overScore" style="margin:0 0 12px">Score: 0</p>
      <button id="restartBtn" style="padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:#012;font-weight:800;cursor:pointer">Play Again</button>
    </div>
  </div>

<script>
/* Black Hole Starcatcher — saved progress + rewards */
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', { alpha:true });
  const VW = 720, VH = 960;
  let scale = 1, DPR = Math.max(1, window.devicePixelRatio || 1);

  function resizeCanvas(){ const w = Math.max(320, Math.floor(VW * Math.min(window.innerWidth / VW, window.innerHeight / VH))); const h = Math.max(480, Math.floor(VH * Math.min(window.innerWidth / VW, window.innerHeight / VH))); canvas.style.width = w + 'px'; canvas.style.height = h + 'px'; canvas.width = Math.floor(w * DPR); canvas.height = Math.floor(h * DPR); ctx.setTransform(DPR,0,0,DPR,0,0); scale = w / VW; }
  window.addEventListener('resize', resizeCanvas); resizeCanvas();

  const state = {
    running:false, lastTime:0, keys:{},
    hole: { x: VW/2, y: VH - 200, radius: 56, vx:0 },
    stars: [], enemies: [], upgrades: [], particles: [],
    score:0, lives:3, level:1, starSpeed:2, waveStars:10, starsCaught:0,
    starTimer:null, adminCode:'', adminCount:0, accessories:[], equipped:{}
  };

  // Saved progress keys
  const STORAGE_KEY = 'BHSC_PROGRESS_v1';

  function loadProgress(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return { bestLevel:0, wavesCleared:0 };
      return JSON.parse(raw);
    }catch(e){ return { bestLevel:0, wavesCleared:0 }; }
  }
  function saveProgress(progress){
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(progress)); }catch(e){}
  }

  // initialize progress
  let progress = loadProgress();
  document.getElementById('best').textContent = progress.bestLevel || 0;
  console.log('Loaded progress:', progress);

  // presets & accessories
  const skins = {
    classic: { coreColor:'#000', ringColor:'#222', glow:'#101010', accent:'#7be3ff' },
    neon: { coreColor:'#050018', ringColor:'#2b0044', glow:'#6d00ff', accent:'#ff6de6' },
    ancient: { coreColor:'#040200', ringColor:'#2b1f00', glow:'#5a3a00', accent:'#ffd66b' }
  };

  let accessoryStore = []; // {id, data, name}
  const accessoryListEl = document.getElementById('accessoryList');
  const accPosSelect = document.getElementById('accPosition');

  function refreshAccessoryList(){
    accessoryListEl.innerHTML = '';
    accessoryStore.forEach(acc => {
      const div = document.createElement('div'); div.className='acc-item';
      const img = document.createElement('img'); img.src = acc.data;
      const label = document.createElement('div'); label.style.fontSize='12px'; label.style.color='#dfeff6'; label.textContent = acc.name || 'Accessory';
      const toggle = document.createElement('input'); toggle.type='checkbox'; toggle.style.marginLeft='6px';
      toggle.checked = !!state.equipped[acc.id];
      toggle.addEventListener('change', ()=>{ if(toggle.checked) state.equipped[acc.id] = { id:acc.id, pos: accPosSelect.value }; else delete state.equipped[acc.id]; });
      div.appendChild(img); div.appendChild(label); div.appendChild(toggle); accessoryListEl.appendChild(div);
    });
  }

  // helper functions
  const rand = (a,b) => Math.random()*(b-a)+a;
  const irand = (a,b) => Math.floor(rand(a,b+1));
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const hit = (ax,ay,ar, bx,by,bw,bh) => ax - ar < bx + bw && ax + ar > bx && ay - ar < by + bh && ay + ar > by;

  // spawn helpers
  function spawnStar(){ const r = irand(8,16); const x = rand(r, VW-r); const hue = irand(200,340); state.stars.push({ x, y:-r*2, r, vx:rand(-0.6,0.6), vy: state.starSpeed + rand(0,1.2), color:`hsl(${hue} 88% 68%)` }); }
  function spawnEnemy(){ const w=44,h=44; const x=rand(40,VW-40-w), y=rand(40,160); const type = Math.random()<0.6?'basic':'kamikaze'; state.enemies.push({ x,y,w,h,type,dir:Math.random()<0.5?-1:1 }); }
  function spawnUpgrade(x,y){ const types=['life','bonus','speed']; const t=types[irand(0,types.length-1)]; state.upgrades.push({ x,y,vy:1.2,r:12,type:t,color: t==='life'?'#7bffb8': t==='bonus'?'#ffd66b':'#cfa0ff' }); }
  function spawnParticle(x,y,c){ for(let i=0;i<8;i++) state.particles.push({ x,y,vx:rand(-2,2),vy:rand(-2,0),life:irand(24,72),col:c }); }

  // gravity
  function applyGravity(){
    const pullRadius = state.hole.radius * 4;
    state.stars.forEach(s => {
      const dx = state.hole.x - s.x, dy = state.hole.y - s.y; const d2 = Math.max(6, Math.sqrt(dx*dx + dy*dy));
      if(d2 < pullRadius){
        const strength = (pullRadius - d2) / pullRadius * 0.45;
        s.vx += (dx / d2) * strength * 0.6;
        s.vy += (dy / d2) * strength * 0.6;
      }
    });
  }

  // timers
  function spawnWave(){
    const n = 1 + Math.floor(state.level/2);
    for(let i=0;i<n;i++) spawnStar();
    if(Math.random() < 0.22 + state.level*0.03) spawnEnemy();
    if(Math.random() < 0.06 + state.level*0.02) spawnUpgrade(rand(40,VW-40), -10);
  }
  function startStarTimer(){ stopStarTimer(); state.starTimer = setInterval(spawnWave, Math.max(260, 900 - state.level*60)); }
  function stopStarTimer(){ if(state.starTimer){ clearInterval(state.starTimer); state.starTimer = null; } }

  // admin & accessory wiring
  document.getElementById('accessoryUpload').addEventListener('change', e=>{
    const f = e.target.files && e.target.files[0]; if(!f) return;
    const fr = new FileReader();
    fr.onload = ev => { const id = 'acc_' + Date.now(); accessoryStore.push({ id, data: ev.target.result, name: f.name }); refreshAccessoryList(); };
    fr.readAsDataURL(f);
  });

  function adminKey(k){
    state.adminCode += k.toString();
    if(state.adminCode.endsWith('67')){ state.adminCount++; state.adminCode=''; }
    if(state.adminCount >= 3){ document.getElementById('adminPanel').style.display = 'block'; document.getElementById('adminPanel').setAttribute('aria-hidden','false'); state.adminCount = 0; state.adminCode=''; refreshAccessoryList(); }
    if(state.adminCode.length > 12) state.adminCode = state.adminCode.slice(-12);
  }
  window.addEventListener('keydown', e => { state.keys[e.key] = true; adminKey(e.key); }, false);
  window.addEventListener('keyup', e => { state.keys[e.key] = false; }, false);
  document.getElementById('hideAdmin').addEventListener('click', ()=>{ document.getElementById('adminPanel').style.display='none'; });

  // UI & controls
  document.getElementById('btnLeft').addEventListener('pointerdown', ()=> state.keys.LeftBtn=true);
  document.getElementById('btnLeft').addEventListener('pointerup', ()=> state.keys.LeftBtn=false);
  document.getElementById('btnRight').addEventListener('pointerdown', ()=> state.keys.RightBtn=true);
  document.getElementById('btnRight').addEventListener('pointerup', ()=> state.keys.RightBtn=false);
  document.getElementById('btnCenter').addEventListener('click', ()=> { state.hole.x = VW/2; });

  document.querySelectorAll('.skin-btn').forEach(b => {
    b.addEventListener('click', ()=> {
      document.querySelectorAll('.skin-btn').forEach(x=>x.classList.remove('active'));
      b.classList.add('active');
      state.skin = b.getAttribute('data-skin');
    });
  });

  document.getElementById('closeGuide').addEventListener('click', ()=> { document.getElementById('guideOverlay').style.display='none'; if(!state.running) startGame(); });
  document.getElementById('restartBtn').addEventListener('click', ()=> { document.getElementById('gameOverOverlay').style.display='none'; restartGame(); });
  document.getElementById('giveLives').addEventListener('click', ()=> { state.lives += 5; updateUI(); });
  document.getElementById('skipWave').addEventListener('click', ()=> { levelComplete(); });

  // update UI
  function updateUI(){ document.getElementById('sc').textContent = state.score; document.getElementById('lv').textContent = state.lives; document.getElementById('lvn').textContent = state.level; document.getElementById('best').textContent = (progress.bestLevel || 0); }

  // reward toast
  const toast = document.getElementById('rewardToast');
  let toastTimer = null;
  function showReward(text){
    toast.textContent = text;
    toast.style.display = 'block';
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>{ toast.style.display = 'none'; }, 2500);
  }

  // level completion & rewards
  function levelComplete(){
    // called when starsCaught reaches waveStars or admin skip
    state.level++;
    state.starSpeed += 0.6;
    state.waveStars += 5;
    state.starsCaught = 0;

    // reward package: lives + score + unlock accessory stub
    const rewardLives = 1 + Math.floor(state.level/5);
    const rewardScore = 10 + state.level * 3;
    state.lives += rewardLives;
    state.score += rewardScore;

    // simulate unlocking an accessory slot (client-only): create a simple colored accessory image (data URI)
    const accId = 'unlock_' + Date.now();
    const canvasAcc = document.createElement('canvas');
    canvasAcc.width = 64; canvasAcc.height = 64;
    const actx = canvasAcc.getContext('2d');
    actx.fillStyle = '#222'; actx.fillRect(0,0,64,64);
    actx.fillStyle = ['#ffd66b','#7be3ff','#cfa0ff','#7bffb8'][state.level % 4];
    actx.beginPath(); actx.arc(32,28,18,0,Math.PI*2); actx.fill();
    actx.fillStyle = '#001'; actx.font = '600 12px sans-serif'; actx.fillText('S'+state.level, 10,54);
    accessoryStore.push({ id: accId, data: canvasAcc.toDataURL(), name: 'Reward ' + state.level });
    // automatically equip new accessory at front
    state.equipped[accId] = { id: accId, pos: 'top' };

    // save progress: update bestLevel and wavesCleared
    progress.wavesCleared = (progress.wavesCleared || 0) + 1;
    if(state.level > (progress.bestLevel || 0)){
      progress.bestLevel = state.level;
      showReward(`Level ${state.level-1} beaten! Reward: +${rewardLives} lives, +${rewardScore} score, new accessory unlocked.`);
    } else {
      showReward(`Wave cleared: +${rewardLives} lives, +${rewardScore} score.`);
    }
    saveProgress(progress);
    updateUI();
    refreshAccessoryList();
  }

  // save progress helper
  function saveProgress(p){
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(p)); }catch(e){}
  }
  const STORAGE_KEY = 'BHSC_PROGRESS_v1';

  // detection of star consumption and game flow
  function applyGravity(){
    const pullRadius = state.hole.radius * 4;
    for(const s of state.stars){
      const dx = state.hole.x - s.x, dy = state.hole.y - s.y;
      const d2 = Math.max(6, Math.sqrt(dx*dx + dy*dy));
      if(d2 < pullRadius){
        const strength = (pullRadius - d2) / pullRadius * 0.45;
        s.vx += (dx / d2) * strength * 0.6;
        s.vy += (dy / d2) * strength * 0.6;
      }
    }
  }

  function finishGame(){
    stopStarTimer();
    state.running = false;
    document.getElementById('overScore').textContent = `Score: ${state.score}`;
    document.getElementById('gameOverOverlay').style.display = 'flex';
    // save best level if higher
    if(state.level > (progress.bestLevel || 0)){
      progress.bestLevel = state.level;
      saveProgress(progress);
      updateUI();
    }
  }

  // main loop
  function loop(ts){
    if(!state.running) return;
    if(!state.lastTime) state.lastTime = ts;
    const dt = Math.min(40, ts - state.lastTime);
    state.lastTime = ts;

    // movement
    const sp = 6;
    if(state.keys['ArrowLeft'] || state.keys['a'] || state.keys.LeftBtn) state.hole.x -= sp;
    if(state.keys['ArrowRight'] || state.keys['d'] || state.keys.RightBtn) state.hole.x += sp;
    state.hole.x = clamp(state.hole.x, 60, VW-60);

    // apply gravity and update stars
    applyGravity();
    for(let i=state.stars.length-1;i>=0;i--){
      const s = state.stars[i];
      s.x += s.vx; s.y += s.vy; s.vy += 0.02;
      const dx = state.hole.x - s.x, dy = state.hole.y - s.y; const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist < state.hole.radius * 0.75){
        state.score++; state.starsCaught++; spawnParticle(s.x,s.y,s.color); state.stars.splice(i,1); updateUI();
        if(state.starsCaught >= state.waveStars){
          levelComplete();
        }
        continue;
      }
      if(s.y - s.r > VH){ state.stars.splice(i,1); state.lives--; spawnParticle(s.x, VH-20, '#ff7b7b'); updateUI(); if(state.lives <= 0){ finishGame(); return; } }
    }

    // enemies
    for(let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];
      if(e.type === 'basic'){
        e.x += e.dir * (1 + state.level*0.08);
        if(e.x < 20 || e.x + e.w > VW-20) e.dir *= -1;
        if(Math.random() < 0.002 + state.level*0.001) e.y += 4;
      } else {
        const dx = state.hole.x - (e.x + e.w/2), dy = state.hole.y - (e.y + e.h/2), mag = Math.sqrt(dx*dx + dy*dy) || 1;
        e.x += (dx / mag) * (1.5 + state.level*0.07); e.y += (dy / mag) * (1.5 + state.level*0.07);
      }
      if(hit(state.hole.x, state.hole.y, state.hole.radius, e.x, e.y, e.w, e.h)){
        state.lives--; updateUI(); spawnParticle(state.hole.x, state.hole.y, '#ff7b7b'); state.enemies.splice(i,1); if(state.lives <= 0){ finishGame(); return; }
      }
      if(e.y > VH + 80 || e.x < -120 || e.x > VW + 120) state.enemies.splice(i,1);
    }

    // upgrades
    for(let i=state.upgrades.length-1;i>=0;i--){
      const u = state.upgrades[i]; u.y += u.vy;
      if(hit(state.hole.x, state.hole.y, state.hole.radius, u.x - u.r, u.y - u.r, u.r*2, u.r*2)){
        if(u.type === 'life') state.lives++; else if(u.type==='bonus') state.score += 3;
        spawnParticle(u.x,u.y,'#fff'); state.upgrades.splice(i,1); updateUI(); continue;
      }
      if(u.y - u.r > VH) state.upgrades.splice(i,1);
    }

    // particles
    for(let i=state.particles.length-1;i>=0;i--){ const p = state.particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.08; p.life--; if(p.life <= 0) state.particles.splice(i,1); }

    // draw
    ctx.clearRect(0,0,VW,VH);
    drawBackground(ts);

    // stars
    state.stars.forEach(s=>{ ctx.save(); ctx.beginPath(); ctx.fillStyle = s.color; ctx.shadowColor = s.color; ctx.shadowBlur = Math.max(6, s.r); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill(); ctx.restore(); });

    // upgrades
    state.upgrades.forEach(u=>{ ctx.save(); ctx.fillStyle = u.color; ctx.beginPath(); ctx.arc(u.x, u.y, u.r, 0, Math.PI*2); ctx.fill(); ctx.restore(); ctx.fillStyle = '#001'; ctx.font = '600 10px Inter, sans-serif'; ctx.fillText(u.type[0].toUpperCase(), u.x-4, u.y+4); });

    // enemies
    state.enemies.forEach(e=>{ ctx.save(); ctx.fillStyle = e.type==='kamikaze' ? '#ff6b6b' : '#b0c4ff'; ctx.fillRect(e.x, e.y, e.w, e.h); ctx.fillStyle = '#001'; ctx.font = '700 12px Inter, sans-serif'; ctx.fillText(e.type[0].toUpperCase(), e.x + e.w/2 - 6, e.y + e.h/2 + 4); ctx.restore(); });

    // black hole (skin + accessories)
    drawBlackHole();

    // particles
    state.particles.forEach(p=>{ ctx.globalAlpha = clamp(p.life/80,0,1); ctx.fillStyle = p.col; ctx.fillRect(p.x, p.y, 2, 2); ctx.globalAlpha = 1; });

    // HUD
    ctx.fillStyle = 'rgba(0,0,0,0.36)'; ctx.fillRect(10,10,260,56); ctx.fillStyle = skins[state.skin].accent; ctx.font = '700 14px Inter, sans-serif'; ctx.fillText(`Score: ${state.score}`, 20, 32); ctx.fillText(`Lives: ${state.lives}`, 20, 52);

    requestAnimationFrame(loop);
  }

  function drawBlackHole(){
    const s = skins[state.skin] || skins.classic;
    const x = state.hole.x, y = state.hole.y, r = state.hole.radius;
    const grad = ctx.createRadialGradient(x, y, r*0.4, x, y, r*2);
    grad.addColorStop(0, s.accent);
    grad.addColorStop(0.4, s.glow);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x, y, r*2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.strokeStyle = s.ringColor; ctx.lineWidth = 8; ctx.arc(x, y, r*0.95, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.fillStyle = s.coreColor; ctx.arc(x, y, r*0.7, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(x, y, r*0.45, 0, Math.PI*2); ctx.fill();

    // accessories
    Object.values(state.equipped).forEach(e=>{
      const acc = accessoryStore.find(a=>a.id === e.id);
      if(!acc) return;
      const img = new Image(); img.src = acc.data;
      let ax = x, ay = y;
      const scaleFactor = 0.9;
      if(e.pos === 'top'){ ax = x; ay = y - r*1.05; }
      else if(e.pos === 'left'){ ax = x - r*1.05; ay = y; }
      else if(e.pos === 'right'){ ax = x + r*1.05; ay = y; }
      else { ax = x; ay = y; }
      const aw = r * 1.1 * scaleFactor, ah = aw;
      ctx.save();
      ctx.beginPath();
      ctx.arc(ax, ay, aw/2 + 2, 0, Math.PI*2); ctx.clip();
      try { ctx.drawImage(img, ax - aw/2, ay - ah/2, aw, ah); } catch(err){}
      ctx.restore();
    });
  }

  function drawBackground(t){
    const g = ctx.createLinearGradient(0,0,VW,VH); g.addColorStop(0,'#021b2b'); g.addColorStop(0.5,'#001021'); g.addColorStop(1,'#000010'); ctx.fillStyle = g; ctx.fillRect(0,0,VW,VH);
    ctx.save(); ctx.globalAlpha = 0.06 + Math.abs(Math.sin(t*0.0003))*0.03; ctx.fillStyle = '#07304a'; ctx.beginPath(); ctx.ellipse(VW*0.18, VH*0.22, 220, 120, 0, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(VW*0.78, VH*0.45, 260, 140, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
    ctx.fillStyle = '#fff'; for(let i=0;i<80;i++){ const sx=(i*47)%(VW-10)+5; const sy=(i*73)%(VH-40)+20; ctx.globalAlpha = 0.2 + 0.6*Math.abs(Math.sin((t*0.001+i)*0.7)); ctx.fillRect(sx,sy,1.2,1.2); } ctx.globalAlpha=1;
  }

  // start & restart
  function startGame(){
    resizeCanvas();
    state.hole.x = VW/2; state.hole.y = VH - 200;
    state.stars = []; state.enemies = []; state.upgrades = []; state.particles = [];
    for(let i=0;i<6;i++) spawnStar();
    for(let i=0;i<1;i++) spawnEnemy();
    startStarTimer();
    state.running = true;
    state.lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  function restartGame(){
    state.score = 0; state.lives = 3; state.level = 1; state.starSpeed = 2; state.waveStars = 10; state.starsCaught = 0;
    updateUI();
    startGame();
  }

  // show saved progress in HUD initially
  updateUI();

  // load initial accessory list from saved progress (if any)
  // (progress management currently only stores bestLevel and wavesCleared)
  if(progress && progress.savedAccessories){
    accessoryStore = progress.savedAccessories;
    refreshAccessoryList();
  }

  // fallback start after guide timeout
  setTimeout(()=>{ if(!state.running && document.getElementById('guideOverlay').style.display === 'none') startGame(); }, 1200);

  // Expose debug
  window.BHSC = { state: ()=> ({score: state.score, lives: state.lives, level: state.level}), reward: ()=> levelComplete(), saveNow: ()=> { saveProgress(progress); } };

})();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Black Hole Starcatcher — Fixed & Improved</title>
<style>
  :root{--ui-bg:rgba(8,10,20,0.6);--accent:#7be3ff;--muted:#cfeefc}
  html,body{height:100%;margin:0;background:radial-gradient(circle at 20% 10%, #071827 0%, #00010a 40%, #000 100%);font-family:Inter,Segoe UI,Arial,sans-serif;color:#fff;overflow:hidden}
  #uiTop{position:fixed;left:10px;right:10px;top:8px;display:flex;justify-content:space-between;gap:12px;z-index:40;align-items:center}
  #scoreboard{background:var(--ui-bg);padding:8px 12px;border-radius:10px;display:flex;gap:12px;align-items:center;font-weight:700}
  #gameWrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
  canvas{display:block;max-width:100%;height:auto;border-radius:14px;box-shadow:0 12px 40px rgba(0,0,0,0.7)}
  #bottomUi{position:fixed;left:10px;right:10px;bottom:12px;display:flex;justify-content:center;gap:12px;z-index:40}
  .control-btn{background:var(--ui-bg);border-radius:8px;padding:8px 12px;color:var(--accent);font-weight:700;border:0;cursor:pointer}
  #adminPanel{display:none;position:fixed;right:14px;top:80px;z-index:80;background:rgba(2,6,12,0.95);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);width:320px;max-width:92%}
  #adminPanel h4{margin:0 0 8px 0;color:var(--accent)}
  #adminPanel .row{display:flex;gap:8px;align-items:center;margin-top:8px}
  #adminPanel input[type=file]{display:block;width:100%}
  #adminPanel .small{font-size:13px;color:#cfeefc;opacity:0.9}
  #accessoryList{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
  .acc-card{background:#07121a;padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);width:70px;text-align:center;font-size:12px;color:#dfeff6}
  .acc-card img{width:64px;height:44px;object-fit:cover;border-radius:6px;display:block;margin:0 auto}
  #guideOverlay{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(2,6,12,0.96);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);max-width:720px;z-index:90}
  #guideOverlay h3{margin:0 0 8px 0;color:var(--accent)}
  #guideSteps{margin-top:8px}
  #rewardToast{position:fixed;left:50%;transform:translateX(-50%);top:12%;background:linear-gradient(90deg,#0b2030,#022);padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);color:#fff;display:none;z-index:85}
  #gameOverOverlay{display:none;position:fixed;inset:0;align-items:center;justify-content:center;background:linear-gradient(0deg, rgba(0,0,0,0.6), rgba(0,0,0,0.2));z-index:100}
  #gameOverCard{background:rgba(6,8,12,0.98);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);text-align:center;min-width:260px}
  #tutorialControls{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.08);color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}
  @media (max-width:600px){#adminPanel{left:8px;right:8px;top:70px;width:auto}}
</style>
</head>
<body>
  <div id="uiTop">
    <div id="scoreboard" aria-live="polite">
      Score: <strong id="sc">0</strong> • Lives: <strong id="lv">3</strong> • Level: <strong id="lvn">1</strong> • Best: <strong id="best">0</strong>
    </div>
    <div style="display:flex;gap:8px;align-items:center;">
      <button id="openGuide" class="btn-ghost">Guide</button>
      <button id="openAdminHint" class="btn-ghost">Admin</button>
    </div>
  </div>

  <div id="gameWrap">
    <canvas id="gameCanvas" width="720" height="960" role="img" aria-label="Black Hole Starcatcher canvas"></canvas>
  </div>

  <div id="bottomUi">
    <button id="btnLeft" class="control-btn">◀</button>
    <button id="btnCenter" class="control-btn">▲</button>
    <button id="btnRight" class="control-btn">▶</button>
  </div>

  <div id="rewardToast"></div>

  <div id="adminPanel" aria-hidden="true">
    <h4>Admin Panel</h4>
    <div class="small">Client-only uploads. Allowed: PNG/JPEG under 1.5MB. Previews and equips here.</div>

    <div class="row">
      <input id="accessoryUpload" type="file" accept="image/png,image/jpeg" />
    </div>

    <div id="accessoryList" aria-live="polite"></div>

    <div class="row">
      <label class="small" style="flex:1">Accessory position</label>
      <select id="accPosition" style="padding:6px;border-radius:6px;background:#031218;color:#fff">
        <option value="top">Top</option>
        <option value="left">Left</option>
        <option value="right">Right</option>
        <option value="front">Front</option>
      </select>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="clearAccessories" class="btn-ghost" style="flex:1">Clear Accessories</button>
      <button id="hideAdmin" class="btn-ghost" style="flex:1">Close</button>
    </div>
  </div>

  <div id="guideOverlay" role="dialog" aria-modal="true">
    <h3>How to play — step-by-step</h3>
    <div id="guideSteps">
      <ol>
        <li>Move the black hole left/right (Arrow keys or on-screen buttons).</li>
        <li>Get close to falling stars — the black hole pulls and eats them for points.</li>
        <li>Dodge enemies; each miss costs a life. If you lose all lives, game over.</li>
        <li>Complete a wave (catch X stars) to clear the level and get rewards.</li>
      </ol>
    </div>
    <div style="margin-top:10px">
      <label style="display:block;font-size:14px;margin-bottom:6px">Tutorial tasks</label>
      <div id="tutorialTasks" style="display:flex;flex-direction:column;gap:6px;">
        <label><input type="checkbox" id="taskMove"> Move left or right once</label>
        <label><input type="checkbox" id="taskCatch"> Catch one star</label>
        <label><input type="checkbox" id="taskOpenAdmin"> Open Admin Panel</label>
      </div>
    </div>

    <div id="tutorialControls">
      <button id="startPlay" class="control-btn">Start Playing</button>
      <button id="dontShow" class="btn-ghost">Don't show again</button>
    </div>

    <div style="margin-top:10px;font-size:13px;color:#cfeefc">Tip: Admin panel is hidden initially. Type "67" three times to open it, or use the Admin button.</div>
  </div>

  <div id="gameOverOverlay">
    <div id="gameOverCard">
      <h2>Game Over</h2>
      <p id="overScore">Score: 0</p>
      <div style="margin-top:10px">
        <button id="restartBtn" class="control-btn" style="background:#7be3ff;color:#012">Play Again</button>
      </div>
    </div>
  </div>

<script>
/*
  Black Hole Starcatcher — fixed, admin improved, tutorial improved.
  - Upload safety / UX: client-only, file type+size checks, preview, equip; accessories persist.
  - Game Over shown only on death, remains for 5 seconds.
  - Tutorial has tasks that auto-check when completed.
  - Progress saved to localStorage (best level, accessories).
  Security & UX notes: used client-side validation and UX best practices for uploads.
*/

(() => {
  // ------ Config / storage keys ------
  const STORAGE_KEY = 'BHSC_PROGRESS_v2';
  const ACCESSORY_KEY = 'BHSC_ACCESSORIES_v2';
  const TUTORIAL_KEY = 'BHSC_TUTORIAL_v2';
  const MAX_FILE_SIZE = 1.5 * 1024 * 1024; // 1.5MB
  const ALLOWED_TYPES = ['image/png', 'image/jpeg'];

  // ------ Canvas & sizing ------
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  const VW = 720, VH = 960;
  let DPR = Math.max(1, window.devicePixelRatio || 1);

  function resizeCanvas(){
    const vw = window.innerWidth, vh = window.innerHeight;
    const scale = Math.min(vw / VW, vh / VH);
    const w = Math.max(320, Math.floor(VW * scale));
    const h = Math.max(480, Math.floor(VH * scale));
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // ------ State ------
  const state = {
    running: false,
    lastTime: 0,
    keys: {},
    hole: { x: VW/2, y: VH - 200, radius: 56 },
    stars: [], enemies: [], upgrades: [], particles: [],
    score: 0, lives: 3, level: 1, starSpeed: 2, waveStars: 10, starsCaught: 0,
    starTimer: null, adminCode: '', adminCount: 0,
    accessories: [], equipped: {}, bestLevel: 0
  };

  // load saved progress & accessories & tutorial flag
  let saved = loadJSON(STORAGE_KEY, { bestLevel: 0 });
  state.bestLevel = saved.bestLevel || 0;
  const accessoryStore = loadJSON(ACCESSORY_KEY, []); // array of {id, dataURL, name, pos}
  const tutorialState = loadJSON(TUTORIAL_KEY, { dontShow: false, tasks: {} });

  // UI refs
  const scEl = document.getElementById('sc');
  const lvEl = document.getElementById('lv');
  const lvnEl = document.getElementById('lvn');
  const bestEl = document.getElementById('best');
  const adminPanel = document.getElementById('adminPanel');
  const accessoryListEl = document.getElementById('accessoryList');
  const accUpload = document.getElementById('accessoryUpload');
  const accPosSelect = document.getElementById('accPosition');
  const rewardToast = document.getElementById('rewardToast');
  const guideOverlay = document.getElementById('guideOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const overScoreEl = document.getElementById('overScore');

  // tutorial tasks refs
  const taskMove = document.getElementById('taskMove');
  const taskCatch = document.getElementById('taskCatch');
  const taskOpenAdmin = document.getElementById('taskOpenAdmin');

  // initial UI
  scEl.textContent = state.score;
  lvEl.textContent = state.lives;
  lvnEl.textContent = state.level;
  bestEl.textContent = state.bestLevel || 0;

  // ------ Utility ------
  function saveJSON(key, value){ try{ localStorage.setItem(key, JSON.stringify(value)); }catch(e){} }
  function loadJSON(key, fallback){ try{ const raw = localStorage.getItem(key); return raw ? JSON.parse(raw) : fallback; }catch(e){ return fallback; } }

  const rand = (a,b)=> Math.random()*(b-a)+a;
  const irand = (a,b)=> Math.floor(rand(a,b+1));
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const hitCircleRect = (cx,cy,cr, rx,ry,rw,rh)=> cx - cr < rx + rw && cx + cr > rx && cy - cr < ry + rh && cy + cr > ry;

  // ------ Spawning / timers ------
  function spawnStar(){ const r = irand(8,16); const x = rand(r, VW-r); const hue = irand(200,340); state.stars.push({ x, y:-r*2, r, vx:rand(-0.6,0.6), vy: state.starSpeed + rand(0,1.2), color:`hsl(${hue} 88% 68%)` }); }
  function spawnEnemy(){ const w=44,h=44; const x=rand(40,VW-40-w), y=rand(40,160); const type = Math.random()<0.6?'basic':'kamikaze'; state.enemies.push({ x,y,w,h,type,dir:Math.random()<0.5?-1:1 }); }
  function spawnUpgrade(x,y){ const types=['life','bonus']; const t = types[irand(0,types.length-1)]; state.upgrades.push({ x,y,vy:1.2,r:12,type:t,color: t==='life'?'#7bffb8':'#ffd66b' }); }
  function spawnParticle(x,y,c){ for(let i=0;i<8;i++) state.particles.push({ x,y,vx:rand(-2,2),vy:rand(-2,0),life:irand(24,72),col:c }); }

  function spawnWave(){
    const n = 1 + Math.floor(state.level/2);
    for(let i=0;i<n;i++) spawnStar();
    if(Math.random() < 0.22 + state.level*0.03) spawnEnemy();
    if(Math.random() < 0.06 + state.level*0.02) spawnUpgrade(rand(40,VW-40), -10);
  }

  function startStarTimer(){
    stopStarTimer();
    state.starTimer = setInterval(spawnWave, Math.max(260, 900 - state.level*60));
  }
  function stopStarTimer(){ if(state.starTimer){ clearInterval(state.starTimer); state.starTimer = null; } }

  // ------ Gameplay: gravity, consumption, level completion ------
  function applyGravity(){
    const pullRadius = state.hole.radius * 4;
    for(const s of state.stars){
      const dx = state.hole.x - s.x, dy = state.hole.y - s.y;
      const d2 = Math.max(6, Math.sqrt(dx*dx + dy*dy));
      if(d2 < pullRadius){
        const strength = (pullRadius - d2) / pullRadius * 0.45;
        s.vx += (dx / d2) * strength * 0.6;
        s.vy += (dy / d2) * strength * 0.6;
      }
    }
  }

  function levelComplete(){
    // reward, progress save, accessory unlock (simple generated badge)
    state.level++;
    state.starSpeed += 0.6;
    state.waveStars += 5;
    state.starsCaught = 0;

    const rewardLives = 1 + Math.floor(state.level/6);
    const rewardScore = 8 + state.level * 3;
    state.lives += rewardLives;
    state.score += rewardScore;

    // generate a simple accessory image and store persistently
    const accId = 'acc_' + Date.now();
    const c = document.createElement('canvas'); c.width = 64; c.height = 40; const cx = c.getContext('2d');
    cx.fillStyle = '#08121a'; cx.fillRect(0,0,64,40);
    cx.fillStyle = ['#ffd66b','#7be3ff','#cfa0ff','#7bffb8'][state.level%4];
    cx.fillRect(8,8,48,24);
    cx.fillStyle = '#001'; cx.font = '600 10px sans-serif'; cx.fillText('L'+state.level, 10, 28);
    accessoryStore.push({ id: accId, data: c.toDataURL('image/png'), name: 'Lvl'+state.level, pos: 'top' });
    saveAccessories();

    // update best level & save
    if(state.level > state.bestLevel) state.bestLevel = state.level;
    saveProgress();

    showReward(`Level cleared! +${rewardLives} lives, +${rewardScore} score. Accessory unlocked.`);
    refreshAccessoryUI();
    updateHUD();
  }

  // ------ Game over: show only on death, lasts 5s ------
  let gameOverTimer = null;
  function finishGame(){
    stopStarTimer();
    state.running = false;
    overScoreEl.textContent = `Score: ${state.score}`;
    gameOverOverlay.style.display = 'flex';
    clearTimeout(gameOverTimer);
    gameOverTimer = setTimeout(()=> {
      // hide overlay after 5s; user must click play to restart
      gameOverOverlay.style.display = 'none';
    }, 5000);
    // save best
    if(state.level > state.bestLevel){ state.bestLevel = state.level; saveProgress(); }
    updateHUD();
  }

  // ------ Save / load helpers ------
  function saveProgress(){
    const p = { bestLevel: state.bestLevel, lastPlayed: Date.now() };
    saveJSON(STORAGE_KEY, p);
    bestEl.textContent = state.bestLevel;
  }
  function saveAccessories(){ saveJSON(ACCESSORY_KEY, accessoryStore); }
  function saveTutorial(){ saveJSON(TUTORIAL_KEY, tutorialState); }

  function saveJSON(key, val){ try{ localStorage.setItem(key, JSON.stringify(val)); }catch(e){} }
  function loadJSON(key, fallback){ try{ const raw = localStorage.getItem(key); return raw ? JSON.parse(raw) : fallback; }catch(e){ return fallback; } }

  // ------ Admin upload: validation, preview, equip, persistent ------
  function refreshAccessoryUI(){
    accessoryListEl.innerHTML = '';
    accessoryStore.forEach(acc => {
      const div = document.createElement('div'); div.className = 'acc-card';
      const img = document.createElement('img'); img.src = acc.data; img.alt = acc.name || 'acc';
      const name = document.createElement('div'); name.textContent = acc.name || 'Accessory';
      const btn = document.createElement('button'); btn.textContent = state.equipped[acc.id] ? 'Unequip' : 'Equip';
      btn.style.marginTop = '6px'; btn.style.width = '100%';
      btn.addEventListener('click', () => {
        if(state.equipped[acc.id]){ delete state.equipped[acc.id]; btn.textContent = 'Equip'; }
        else { state.equipped[acc.id] = { id: acc.id, pos: accPosSelect.value }; btn.textContent = 'Unequip'; }
        saveAccessories();
      });
      div.appendChild(img); div.appendChild(name); div.appendChild(btn);
      accessoryListEl.appendChild(div);
    });
  }

  accUpload.addEventListener('change', (ev) => {
    const f = ev.target.files && ev.target.files[0];
    if(!f) return;
    // client-side validation: type and size
    if(!ALLOWED_TYPES.includes(f.type)){ alert('Only PNG or JPEG allowed'); return; }
    if(f.size > MAX_FILE_SIZE){ alert('File too large. Max 1.5MB'); return; }
    // read & store as data URL
    const fr = new FileReader();
    fr.onload = (e) => {
      const id = 'acc_' + Date.now();
      accessoryStore.push({ id, data: e.target.result, name: f.name, pos: accPosSelect.value });
      saveAccessories();
      refreshAccessoryUI();
      // auto-equip newly uploaded accessory
      state.equipped[id] = { id, pos: accPosSelect.value };
      saveAccessories();
    };
    fr.readAsDataURL(f);
    // reset input so same file can be re-selected later
    ev.target.value = '';
  });

  document.getElementById('clearAccessories').addEventListener('click', () => {
    if(confirm('Clear all accessories from storage?')) {
      accessoryStore.length = 0;
      Object.keys(state.equipped).forEach(k => delete state.equipped[k]);
      saveAccessories();
      refreshAccessoryUI();
    }
  });

  document.getElementById('hideAdmin').addEventListener('click', () => { adminPanel.style.display = 'none'; adminPanel.setAttribute('aria-hidden','true'); });

  // Admin open button hint (also allow opening via button rather than typing)
  document.getElementById('openAdminHint').addEventListener('click', ()=> {
    adminPanel.style.display = 'block';
    adminPanel.setAttribute('aria-hidden','false');
    refreshAccessoryUI();
  });

  // ------ Tutorial improvements ------
  const startPlayBtn = document.getElementById('startPlay');
  const dontShowBtn = document.getElementById('dontShow');

  startPlayBtn.addEventListener('click', ()=> {
    // record tutorial tasks state
    tutorialState.dontShow = tutorialState.dontShow || false;
    saveTutorial();
    guideOverlay.style.display = 'none';
    // start game only after closing guide
    if(!state.running) startGame();
  });
  dontShowBtn.addEventListener('click', ()=> {
    tutorialState.dontShow = true;
    saveTutorial();
    guideOverlay.style.display = 'none';
    if(!state.running) startGame();
  });

  // auto-check tutorial tasks
  function markTask(id){
    tutorialState.tasks[id] = true;
    saveTutorial();
    if(id === 'move') taskMove.checked = true;
    if(id === 'catch') taskCatch.checked = true;
    if(id === 'openAdmin') taskOpenAdmin.checked = true;
  }

  // show guide if user hasn't disabled it
  if(tutorialState.dontShow){
    guideOverlay.style.display = 'none';
  } else {
    guideOverlay.style.display = 'block';
  }

  // Guide open button
  document.getElementById('openGuide').addEventListener('click', ()=> { guideOverlay.style.display = 'block'; });

  // ------ HUD & accessory draw ------
  function updateHUD(){
    scEl.textContent = state.score;
    lvEl.textContent = state.lives;
    lvnEl.textContent = state.level;
    bestEl.textContent = state.bestLevel;
  }

  function drawBlackHole(){
    const x = state.hole.x, y = state.hole.y, r = state.hole.radius;
    // glow
    const grad = ctx.createRadialGradient(x,y,r*0.4,x,y,r*2);
    grad.addColorStop(0,'#7be3ff'); grad.addColorStop(0.4,'rgba(123,227,255,0.12)'); grad.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x,y,r*2,0,Math.PI*2); ctx.fill();
    // ring
    ctx.beginPath(); ctx.strokeStyle = '#222'; ctx.lineWidth = 8; ctx.arc(x,y,r*0.95,0,Math.PI*2); ctx.stroke();
    // core
    ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(x,y,r*0.7,0,Math.PI*2); ctx.fill();
    // event horizon
    ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(x,y,r*0.45,0,Math.PI*2); ctx.fill();

    // draw accessories equipped
    Object.values(state.equipped).forEach(e => {
      const acc = accessoryStore.find(a => a.id === e.id);
      if(!acc) return;
      const img = new Image();
      img.src = acc.data;
      // position
      let ax = x, ay = y;
      const scaleFactor = 0.9;
      if(e.pos === 'top') { ax = x; ay = y - r*1.05; }
      else if(e.pos === 'left') { ax = x - r*1.05; ay = y; }
      else if(e.pos === 'right') { ax = x + r*1.05; ay = y; }
      else { ax = x; ay = y; }
      const aw = r * 1.1 * scaleFactor, ah = aw * (44/64);
      ctx.save();
      ctx.beginPath(); ctx.arc(ax, ay, aw/2 + 2, 0, Math.PI*2); ctx.clip();
      try { ctx.drawImage(img, ax - aw/2, ay - ah/2, aw, ah); } catch(err) {}
      ctx.restore();
    });
  }

  // ------ Main loop ------
  function loop(ts){
    if(!state.running) return;
    if(!state.lastTime) state.lastTime = ts;
    const dt = Math.min(40, ts - state.lastTime);
    state.lastTime = ts;

    // input move
    const speed = 6;
    if(state.keys['ArrowLeft'] || state.keys['a'] || state.keys.LeftBtn) { state.hole.x -= speed; markTask('move'); }
    if(state.keys['ArrowRight'] || state.keys['d'] || state.keys.RightBtn) { state.hole.x += speed; markTask('move'); }
    state.hole.x = clamp(state.hole.x, 60, VW-60);

    // gravity
    applyGravity();

    // update stars
    for(let i=state.stars.length-1;i>=0;i--){
      const s = state.stars[i];
      s.x += s.vx; s.y += s.vy; s.vy += 0.02;
      const dx = state.hole.x - s.x, dy = state.hole.y - s.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist < state.hole.radius * 0.75){
        state.score++; state.starsCaught++;
        spawnParticle(s.x, s.y, s.color);
        state.stars.splice(i,1);
        markTask('catch');
        updateHUD();
        if(state.starsCaught >= state.waveStars) levelComplete();
        continue;
      }
      if(s.y - s.r > VH){
        state.stars.splice(i,1);
        state.lives--;
        spawnParticle(s.x, VH - 20, '#ff7b7b');
        updateHUD();
        if(state.lives <= 0){ finishGame(); return; }
      }
    }

    // enemies
    for(let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];
      if(e.type === 'basic'){ e.x += e.dir * (1 + state.level*0.08); if(e.x < 20 || e.x + e.w > VW-20) e.dir *= -1; if(Math.random() < 0.002 + state.level*0.001) e.y += 4; }
      else { const dx = state.hole.x - (e.x + e.w/2), dy = state.hole.y - (e.y + e.h/2); const mag = Math.sqrt(dx*dx + dy*dy) || 1; e.x += (dx / mag) * (1.5 + state.level*0.07); e.y += (dy / mag) * (1.5 + state.level*0.07); }
      if(hitCircleRect(state.hole.x, state.hole.y, state.hole.radius, e.x, e.y, e.w, e.h)){
        state.lives--; updateHUD(); spawnParticle(state.hole.x, state.hole.y, '#ff7b7b'); state.enemies.splice(i,1); if(state.lives <= 0){ finishGame(); return; }
      }
      if(e.y > VH + 80 || e.x < -120 || e.x > VW + 120) state.enemies.splice(i,1);
    }

    // upgrades
    for(let i=state.upgrades.length-1;i>=0;i--){
      const u = state.upgrades[i];
      u.y += u.vy;
      if(hitCircleRect(state.hole.x, state.hole.y, state.hole.radius, u.x - u.r, u.y - u.r, u.r*2, u.r*2)){
        if(u.type === 'life') state.lives++; else state.score += 3;
        spawnParticle(u.x, u.y, '#fff'); state.upgrades.splice(i,1); updateHUD(); continue;
      }
      if(u.y - u.r > VH) state.upgrades.splice(i,1);
    }

    // particles
    for(let i=state.particles.length-1;i>=0;i--){ const p = state.particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.08; p.life--; if(p.life <= 0) state.particles.splice(i,1); }

    // draw
    ctx.clearRect(0,0,VW,VH);
    drawBackground(ts);

    // stars
    state.stars.forEach(s => { ctx.save(); ctx.beginPath(); ctx.fillStyle = s.color; ctx.shadowColor = s.color; ctx.shadowBlur = Math.max(6, s.r); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill(); ctx.restore(); });

    // upgrades
    state.upgrades.forEach(u => { ctx.save(); ctx.fillStyle = u.color; ctx.beginPath(); ctx.arc(u.x, u.y, u.r, 0, Math.PI*2); ctx.fill(); ctx.restore(); ctx.fillStyle = '#001'; ctx.font = '600 10px Inter, sans-serif'; ctx.fillText(u.type[0].toUpperCase(), u.x-4, u.y+4); });

    // enemies
    state.enemies.forEach(e => { ctx.save(); ctx.fillStyle = e.type==='kamikaze' ? '#ff6b6b' : '#b0c4ff'; ctx.fillRect(e.x, e.y, e.w, e.h); ctx.fillStyle = '#001'; ctx.font = '700 12px Inter, sans-serif'; ctx.fillText(e.type[0].toUpperCase(), e.x + e.w/2 - 6, e.y + e.h/2 + 4); ctx.restore(); });

    // black hole & accessories
    drawBlackHole();

    // particles
    state.particles.forEach(p => { ctx.globalAlpha = clamp(p.life/80,0,1); ctx.fillStyle = p.col; ctx.fillRect(p.x, p.y, 2, 2); ctx.globalAlpha = 1; });

    // HUD is on DOM; internal canvas shows small HUD as well
    ctx.fillStyle = 'rgba(0,0,0,0.36)'; ctx.fillRect(10,10,260,56); ctx.fillStyle = '#7be3ff'; ctx.font = '700 14px Inter, sans-serif'; ctx.fillText(`Score: ${state.score}`, 20, 32); ctx.fillText(`Lives: ${state.lives}`, 20, 52);

    requestAnimationFrame(loop);
  }

  function drawBackground(t){
    const g = ctx.createLinearGradient(0,0,VW,VH); g.addColorStop(0,'#021b2b'); g.addColorStop(0.5,'#001021'); g.addColorStop(1,'#000010'); ctx.fillStyle = g; ctx.fillRect(0,0,VW,VH);
    ctx.save(); ctx.globalAlpha = 0.06 + Math.abs(Math.sin(t*0.0003))*0.03; ctx.fillStyle = '#07304a'; ctx.beginPath(); ctx.ellipse(VW*0.18, VH*0.22, 220, 120, 0, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(VW*0.78, VH*0.45, 260, 140, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
    ctx.fillStyle = '#fff'; for(let i=0;i<80;i++){ const sx=(i*47)%(VW-10)+5; const sy=(i*73)%(VH-40)+20; ctx.globalAlpha = 0.2 + 0.6*Math.abs(Math.sin((t*0.001+i)*0.7)); ctx.fillRect(sx,sy,1.2,1.2); } ctx.globalAlpha = 1;
  }

  // Draw black hole & equipped accessories from accessoryStore/state.equipped
  function drawBlackHole(){
    const x = state.hole.x, y = state.hole.y, r = state.hole.radius;
    const grad = ctx.createRadialGradient(x,y,r*0.4,x,y,r*2); grad.addColorStop(0,'#7be3ff'); grad.addColorStop(0.4,'rgba(123,227,255,0.12)'); grad.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x,y,r*2,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.strokeStyle = '#222'; ctx.lineWidth = 8; ctx.arc(x,y,r*0.95,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(x,y,r*0.7,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(x,y,r*0.45,0,Math.PI*2); ctx.fill();

    // draw each equipped accessory
    Object.values(state.equipped).forEach(e => {
      const acc = accessoryStore.find(a => a.id === e.id);
      if(!acc) return;
      const img = new Image(); img.src = acc.data;
      let ax = x, ay = y;
      if(e.pos === 'top') { ax = x; ay = y - r*1.05; }
      else if(e.pos === 'left') { ax = x - r*1.05; ay = y; }
      else if(e.pos === 'right') { ax = x + r*1.05; ay = y; }
      else { ax = x; ay = y; }
      const aw = r * 1.1, ah = aw * (44/64);
      ctx.save(); ctx.beginPath(); ctx.arc(ax, ay, aw/2 + 2, 0, Math.PI*2); ctx.clip();
      try { ctx.drawImage(img, ax - aw/2, ay - ah/2, aw, ah); } catch(e){}
      ctx.restore();
    });
  }

  // ------ Start/Restart controls ------
  document.getElementById('btnLeft').addEventListener('pointerdown', ()=> state.keys.LeftBtn = true);
  document.getElementById('btnLeft').addEventListener('pointerup', ()=> state.keys.LeftBtn = false);
  document.getElementById('btnRight').addEventListener('pointerdown', ()=> state.keys.RightBtn = true);
  document.getElementById('btnRight').addEventListener('pointerup', ()=> state.keys.RightBtn = false);
  document.getElementById('btnCenter').addEventListener('click', ()=> state.hole.x = VW/2);

  // keyboard handlers + admin code detection
  window.addEventListener('keydown', (e) => {
    state.keys[e.key] = true;
    // admin hidden trigger: type "67" three times
    state.adminCode += e.key.toString();
    if(state.adminCode.endsWith('67')){ state.adminCount++; state.adminCode = ''; }
    if(state.adminCount >= 3){ adminPanel.style.display = 'block'; adminPanel.setAttribute('aria-hidden','false'); refreshAccessoryUI(); state.adminCount = 0; state.adminCode = ''; markTask('openAdmin'); }
    if(state.adminCode.length > 12) state.adminCode = state.adminCode.slice(-12);
  }, false);
  window.addEventListener('keyup', (e) => { state.keys[e.key] = false; }, false);

  // open admin with button
  document.getElementById('openAdminHint').addEventListener('click', () => { adminPanel.style.display = 'block'; adminPanel.setAttribute('aria-hidden','false'); refreshAccessoryUI(); markTask('openAdmin'); });

  // restart
  document.getElementById('restartBtn').addEventListener('click', () => {
    // hide overlay immediately and restart the game
    gameOverOverlay.style.display = 'none';
    resetGame();
    startGame();
  });

  // ------ Reset and start game ------
  function resetGame(){
    // reset variables but keep accessories & progress
    state.stars.length = 0; state.enemies.length = 0; state.upgrades.length = 0; state.particles.length = 0;
    state.score = 0; state.lives = 3; state.level = 1; state.starSpeed = 2; state.waveStars = 10; state.starsCaught = 0;
    state.lastTime = 0;
    updateHUD();
  }

  function startGame(){
    if(state.running) return;
    resetGame();
    // initial spawns
    for(let i=0;i<6;i++) spawnStar();
    spawnEnemy();
    startStarTimer();
    state.running = true;
    state.lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  // Start automatically if tutorial disabled; otherwise wait for guide close button
  if(!tutorialState.dontShow) {
    // guide visible; user must start via Guide controls
  } else {
    startGame();
  }

  // ------ Tutorial automation hooks ------
  function markTask(task){
    tutorialState.tasks[task] = true;
    saveTutorial();
    if(task === 'move') taskMove.checked = true;
    if(task === 'catch') taskCatch.checked = true;
    if(task === 'openAdmin') taskOpenAdmin.checked = true;
  }

  // helper: show reward toast
  let toastTimer = null;
  function showReward(text){
    rewardToast.textContent = text; rewardToast.style.display = 'block';
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=> rewardToast.style.display = 'none', 2600);
  }

  // ------ Accessories persistence & UI init ------
  function refreshAccessoryUI(){
    accessoryListEl.innerHTML = '';
    accessoryStore.forEach(acc => {
      const node = document.createElement('div'); node.className = 'acc-card';
      const img = document.createElement('img'); img.src = acc.data;
      const label = document.createElement('div'); label.textContent = acc.name || 'Accessory';
      const btn = document.createElement('button'); btn.textContent = state.equipped[acc.id] ? 'Unequip' : 'Equip';
      btn.style.marginTop = '6px'; btn.style.width = '100%';
      btn.addEventListener('click', ()=> {
        if(state.equipped[acc.id]){ delete state.equipped[acc.id]; btn.textContent = 'Equip'; }
        else { state.equipped[acc.id] = { id: acc.id, pos: acc.pos || accPosSelect.value }; btn.textContent = 'Unequip'; }
        saveAccessories();
      });
      node.appendChild(img); node.appendChild(label); node.appendChild(btn);
      accessoryListEl.appendChild(node);
    });
  }

  // load accessories from storage into accessoryStore
  function initAccessories(){
    const stored = loadJSON(ACCESSORY_KEY, []);
    if(stored && Array.isArray(stored)) {
      accessoryStore.length = 0;
      stored.forEach(s => accessoryStore.push(s));
    }
    // restore equipped map (if any)
    const eq = loadJSON(ACCESSORY_KEY + '_equipped', {});
    if(eq && typeof eq === 'object') state.equipped = eq;
    refreshAccessoryUI();
  }
  function saveAccessories(){
    saveJSON(ACCESSORY_KEY, accessoryStore);
    saveJSON(ACCESSORY_KEY + '_equipped', state.equipped);
  }

  // init accessories on load
  initAccessories();

  // ------ Helpers & misc ------
  function updateHUD(){ scEl.textContent = state.score; lvEl.textContent = state.lives; lvnEl.textContent = state.level; bestEl.textContent = state.bestLevel; }
  function showToast(msg){ showReward(msg); }

  // allow UI-driven start if guide open
  document.getElementById('startPlay').addEventListener('click', ()=> {
    guideOverlay.style.display = 'none';
    tutorialState.dontShow = false;
    saveTutorial();
    startGame();
  });
  document.getElementById('dontShow').addEventListener('click', ()=> {
    tutorialState.dontShow = true;
    saveTutorial();
    guideOverlay.style.display = 'none';
    startGame();
  });

  // initial UI states
  updateHUD();
  refreshAccessoryUI();

  // Safety note: all file uploads are validated client-side and kept local. This reduces attack surface but does not remove all risks; do not use this code to accept untrusted files on a server.

  // ------ End of main IIFE ------
})();
</script>
</body>
</html>

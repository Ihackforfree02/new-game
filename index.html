<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Bullet Heart Duel — Run Mode</title>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<style>
  html,body { margin:0; background:#0b0b0f; color:#e7e7ef; font:14px/1.5 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
  #wrap { display:flex; flex-direction:column; align-items:center; gap:8px; padding:10px; }
  canvas { background:#000; border:2px solid #e7e7ef; image-rendering: pixelated; touch-action:none; }
  .hud { width: 920px; max-width: 96vw; display:flex; justify-content:space-between; align-items:center; }
  .small { font-size:12px; opacity:.8; }
  .bar { height:10px; background:#26263b; border:1px solid #3a3a5d; position:relative; width:240px; }
  .fill { height:100%; background:#7affb7; }
  .bar.blue .fill { background:#6cb6ff; }
  .pill { padding:4px 8px; border-radius:999px; border:1px solid #3a3a5d; }
  button { background:#191924; color:#e7e7ef; border:1px solid #3a3a5d; padding:6px 10px; cursor:pointer; }
  button:hover { background:#20203a; }
</style>
</head>
<body>
<div id="wrap">
  <div class="hud" id="hudTop">
    <span id="status">Move: WASD/Arrows • Burst: E • Shoot: Space (Boss Attack) • P: Pause • M: Mute • K: Skin</span>
    <div style="display:flex; gap:8px;">
      <button id="pauseBtn">Pause</button>
      <button id="muteBtn">Mute</button>
      <button id="resetBtn">Reset run</button>
    </div>
  </div>

  <canvas id="game" width="920" height="660"></canvas>

  <div class="hud" id="hudBottom">
    <div style="display:flex; gap:16px; align-items:center;">
      <span>HP</span>
      <div class="bar"><div id="hpFill" class="fill" style="width:100%;"></div></div>
      <span id="hpText"></span>
    </div>
    <div style="display:flex; gap:16px; align-items:center;">
      <span>Burst</span>
      <div class="bar blue"><div id="burstFill" class="fill" style="width:0%;"></div></div>
      <span id="burstText"></span>
    </div>
    <div style="display:flex; gap:16px; align-items:center;">
      <span class="pill" id="lvText"></span>
      <span class="pill" id="phaseText"></span>
      <span class="pill" id="timerText"></span>
      <span class="pill" id="scoreText"></span>
      <span class="pill" id="skinText"></span>
    </div>
  </div>

  <div class="small">Single-file fangame-style engine. Progress and HP save automatically.</div>
</div>

<script>
(() => {
  'use strict';

  // ======================= CONFIG =======================
  const CONFIG = {
    arena: { x: 160, y: 120, w: 600, h: 440, border: 3, color: '#c9c9ff' },
    player: {
      r: 7, speed: 3.1, boost: 1.25,
      iframes: 800, maxHP: 92,
      grazeRadius: 18, grazeScore: 3, dmgShake: 5
    },
    cycle: { surviveSec: 60, attackSec: 10 }, // boss cycles only
    sfx: { enabled: true, vol: 0.18 },
    bullets: { playerSpeed: 6.5, playerCooldown: 140, playerDmg: 10 },
    burst: { max: 100, gainPerGraze: 1.2, damage: 120, clearBullets: true, cooldown: 3000 },
    visual: {
      bg:'#000', trail:true, trailAlpha:0.07,
      warn:'#ffd166', beam:'#73c0ff',
      bone:'#e5e5ff', knife:'#ffaa99', orb:'#a1ffea',
      fall:'#ffcc88', hammer:'#ff9d6c', fire:'#ff6b3d', heal:'#7affb7'
    },
    saveKey: 'bhd_run_v2'
  };

  const SKINS = [
    { id:'classic', name:'Classic', color:'#ff4d6d', trail:'#ffb3c1' },
    { id:'ember',   name:'Ember',   color:'#ff9a63', trail:'#ffd0b7' },
    { id:'sapphire',name:'Sapphire',color:'#59b0ff', trail:'#b7daff' },
    { id:'emerald', name:'Emerald', color:'#53ffa3', trail:'#b9ffd6' },
    { id:'void',    name:'Void',    color:'#d5ccff', trail:'#a18aff' }
  ];

  // ======================= DOM =======================
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const hpFill = document.getElementById('hpFill');
  const hpText = document.getElementById('hpText');
  const burstFill = document.getElementById('burstFill');
  const burstText = document.getElementById('burstText');
  const lvText = document.getElementById('lvText');
  const phaseText = document.getElementById('phaseText');
  const timerText = document.getElementById('timerText');
  const scoreText = document.getElementById('scoreText');
  const skinText = document.getElementById('skinText');

  document.getElementById('pauseBtn').onclick = ()=> paused = !paused;
  document.getElementById('muteBtn').onclick = ()=> { CONFIG.sfx.enabled = !CONFIG.sfx.enabled; persist(); };
  document.getElementById('resetBtn').onclick = hardReset;

  // ======================= SAVE =======================
  function loadSave(){
    try{
      const raw = localStorage.getItem(CONFIG.saveKey);
      if (!raw) return { level:1, hp:CONFIG.player.maxHP, best:0, skin:'classic', unlocked:['classic'], muted:false };
      const s = JSON.parse(raw);
      if (s.muted) CONFIG.sfx.enabled = false;
      // sanitize
      s.level = Math.max(1, s.level|0);
      s.hp = Math.max(1, Math.min(CONFIG.player.maxHP, s.hp|0));
      s.unlocked = Array.isArray(s.unlocked) && s.unlocked.length ? s.unlocked : ['classic'];
      s.skin = s.unlocked.includes(s.skin) ? s.skin : s.unlocked[0];
      s.best = s.best|0;
      return s;
    } catch(e){
      return { level:1, hp:CONFIG.player.maxHP, best:0, skin:'classic', unlocked:['classic'], muted:false };
    }
  }
  function persist(){
    try{
      localStorage.setItem(CONFIG.saveKey, JSON.stringify({
        level: save.level,
        hp: Math.max(0, Math.ceil(game?.player?.hp ?? save.hp)),
        best: save.best|0,
        skin: save.skin,
        unlocked: Array.from(new Set(save.unlocked)),
        muted: !CONFIG.sfx.enabled
      }));
    }catch(e){}
  }
  function hardReset(){
    save = { level:1, hp:CONFIG.player.maxHP, best:0, skin:'classic', unlocked:['classic'], muted:!CONFIG.sfx.enabled };
    persist();
    startRun();
  }
  let save = loadSave();

  // ======================= AUDIO =======================
  let audioCtx;
  function tone(freq, dur=0.06, type='square', vol=CONFIG.sfx.vol){
    if (!CONFIG.sfx.enabled) return;
    try{
      audioCtx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
      const o = audioCtx.createOscillator(), g = audioCtx.createGain();
      o.type=type; o.frequency.value=freq;
      g.gain.value=0; g.gain.linearRampToValueAtTime(vol, audioCtx.currentTime+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+dur);
      o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+dur+0.02);
    }catch(e){}
  }

  // ======================= UTIL =======================
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a + Math.random()*(b-a);
  const dist2=(x1,y1,x2,y2)=>{const dx=x2-x1,dy=y2-y1;return dx*dx+dy*dy;};
  const circleRectHit=(cx,cy,r, rx,ry,rw,rh)=>{const nx=clamp(cx,rx,rx+rw),ny=clamp(cy,ry,ry+rh);const dx=cx-nx,dy=cy-ny;return dx*dx+dy*dy<=r*r;};

  // ======================= ENTITIES =======================
  const bullets=[];   // enemy bullets
  const hazards=[];   // beams, falls, hammers, fires
  const telegraphs=[];
  const pshots=[];
  const floatTexts=[];

  function clearWave(){ bullets.length=0; hazards.length=0; telegraphs.length=0; pshots.length=0; floatTexts.length=0; }

  function popup(x,y,text,color='#7affb7'){ floatTexts.push({x,y,vy:-0.4,t:0,life:900,text,color}); }

  // enemy spawners
  function spawnOrb(x,y,vx,vy,r=6,dmg=7){ bullets.push({kind:'orb',x,y,vx,vy,r,dmg,color:CONFIG.visual.orb}); }
  function spawnBone(x,y,w,h,vx,vy,dmg=8){ bullets.push({kind:'rect',x,y,w,h,vx,vy,dmg,color:CONFIG.visual.bone}); }
  function spawnKnife(x,y,ang,spd,dmg=10){ bullets.push({kind:'knife',x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,w:6,h:16,angle:ang,spin:0.18,dmg,color:CONFIG.visual.knife}); }
  function spawnBeam(x,y,w,h,delay=500,hold=600,dmg=12){
    telegraphs.push({kind:'beamWarn',x,y,w,h,t:0,delay}); hazards.push({kind:'beam',x,y,w,h,active:false,t:0,hold,dmg,color:CONFIG.visual.beam});
  }
  function spawnHammerColumn(x,delay=700,hold=500,dmg=14){
    telegraphs.push({kind:'hammerWarnCol',x,delay,t:0}); hazards.push({kind:'hammerCol',x,active:false,t:0,w:70,hold,dmg,color:CONFIG.visual.hammer});
  }
  function spawnHammerArc(cx,cy,radius,span,delay=700,hold=450,dmg=14){
    telegraphs.push({kind:'hammerWarnArc',cx,cy,radius,span,delay,t:0}); hazards.push({kind:'hammerArc',cx,cy,radius,span,active:false,t:0,hold,dmg,color:CONFIG.visual.hammer});
  }
  // Fire: jets and fireballs
  function spawnFireJetVertical(x, delay=600, hold=900, dmg=10){
    telegraphs.push({kind:'fireWarnCol',x,delay,t:0}); hazards.push({kind:'fireCol',x,active:false,t:0,w:40,hold,dmg,color:CONFIG.visual.fire});
  }
  function spawnFireBall(x,y,ang,spd=2.2,r=7,dmg=9){
    bullets.push({kind:'fire',x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,r,dmg,color:CONFIG.visual.fire, flicker:0});
  }

  // player shots
  function spawnPShot(x,y,dx,dy){
    const sp = CONFIG.bullets.playerSpeed; const n = Math.hypot(dx,dy)||1;
    pshots.push({x,y,vx:dx/n*sp,vy:dy/n*sp,r:3,color:'#c0ff7a',dmg:CONFIG.bullets.playerDmg});
  }

  // ======================= PATTERNS =======================
  const Patterns = {
    // generic survival patterns for non-boss levels
    corridorBeams: (t,dt,a,lvl)=>{
      t.acc=(t.acc||0)+dt;
      if (t.acc>1100){
        t.acc=0;
        const rows = 2 + (lvl%3);
        for (let i=0;i<rows;i++){
          if (Math.random()<0.5){
            const y = Math.floor(rand(a.y+50,a.y+a.h-50));
            spawnBeam(a.x,y,a.w,8, 480-20*lvl, 640, 10+lvl);
          } else {
            const x = Math.floor(rand(a.x+50,a.x+a.w-50));
            spawnBeam(x,a.y,8,a.h, 480-20*lvl, 640, 10+lvl);
          }
        }
        tone(300,0.04,'sine');
      }
    },
    crossBones: (t,dt,a,lvl)=>{
      t.acc=(t.acc||0)+dt;
      if (t.acc > 260){
        t.acc=0;
        const s = 2.0 + 0.15*lvl;
        const y = Math.floor(rand(a.y+20,a.y+a.h-20));
        spawnBone(a.x-24,y,22,10, s,0,8+lvl);
        spawnBone(a.x+a.w+4,y,22,10, -s,0,8+lvl);
        const x = Math.floor(rand(a.x+20,a.x+a.w-20));
        spawnBone(x,a.y-24,10,22, 0,s,8+lvl);
        spawnBone(x,a.y+a.h+4,10,22, 0,-s,8+lvl);
        tone(420,0.03);
      }
    },
    chaseOrbs: (t,dt,a,lvl,player)=>{
      t.acc=(t.acc||0)+dt;
      if (t.acc>520-20*lvl){
        t.acc=0;
        const edges = [
          {x: rand(a.x, a.x+a.w), y: a.y-10},
          {x: rand(a.x, a.x+a.w), y: a.y+a.h+10},
          {x: a.x-10, y: rand(a.y, a.y+a.h)},
          {x: a.x+a.w+10, y: rand(a.y, a.y+a.h)}
        ];
        for (let k=0;k<2+Math.floor(lvl/3);k++){
          const e = edges[Math.floor(rand(0,4))];
          const ang = Math.atan2(player.y - e.y, player.x - e.x);
          spawnOrb(e.x,e.y, Math.cos(ang)*(1.7+0.18*lvl), Math.sin(ang)*(1.7+0.18*lvl), 7, 7+lvl);
        }
      }
      bullets.forEach(b=>{
        if (b.kind==='orb'){
          const ang = Math.atan2(game.player.y - b.y, game.player.x - b.x);
          b.vx = b.vx*0.97 + Math.cos(ang)*0.06*(1+0.02*lvl);
          b.vy = b.vy*0.97 + Math.sin(ang)*0.06*(1+0.02*lvl);
        }
      });
    },
    // boss-only: hammers + fire
    hammerAndFire: (t,dt,a,lvl,player)=>{
      t.acc=(t.acc||0)+dt; t.fire=(t.fire||0)+dt;
      if (t.acc>1400){
        t.acc=0;
        // columns and arcs
        const cols = 2 + Math.floor(lvl/2);
        for (let i=0;i<cols;i++){
          const x = Math.floor(rand(a.x+60, a.x+a.w-60));
          spawnHammerColumn(x, 580-20*lvl, 520+40*lvl, 12+lvl);
        }
        const cx = a.x + a.w/2, cy = a.y + a.h/2;
        const span = Math.PI/3 + lvl*0.12;
        const ang = Math.atan2(player.y-cy, player.x-cx);
        spawnHammerArc(cx,cy, 160+lvl*16, {a:ang-span/2, b:ang+span/2}, 540-20*lvl, 480+30*lvl, 12+lvl);
        tone(200,0.06,'triangle');
      }
      if (t.fire>360){
        t.fire=0;
        // fire jets + fireballs
        const jets = 1 + Math.floor(lvl/3);
        for (let i=0;i<jets;i++){
          const x = Math.floor(rand(a.x+50, a.x+a.w-50));
          spawnFireJetVertical(x, 420-10*lvl, 800, 8+lvl);
        }
        const balls = 3 + Math.floor(lvl/2);
        for (let i=0;i<balls;i++){
          const pos = [
            {x: rand(a.x,a.x+a.w), y: a.y-10},
            {x: rand(a.x,a.x+a.w), y: a.y+a.h+10},
            {x: a.x-10, y: rand(a.y,a.y+a.h)},
            {x: a.x+a.w+10, y: rand(a.y,a.y+a.h)}
          ][Math.floor(rand(0,4))];
          const ang = Math.atan2(player.y-pos.y, player.x-pos.x) + rand(-0.2,0.2);
          spawnFireBall(pos.x,pos.y, ang, 2.1+0.1*lvl, 7, 9+lvl);
        }
        tone(360,0.05,'sawtooth');
      }
    }
  };

  // ======================= BOSSES =======================
  const Bosses = [
    { name:'Hammer Saint', color:'#ffd2ae', hp: 1000, patterns: [(t,dt,a,l,p)=>Patterns.hammerAndFire(t,dt,a,2,p)] },
    { name:'Forge Warden', color:'#ffb38f', hp: 1200, patterns: [(t,dt,a,l,p)=>Patterns.hammerAndFire(t,dt,a,3,p)] },
    { name:'Anvil Sovereign', color:'#ffcaa1', hp: 1400, patterns: [(t,dt,a,l,p)=>Patterns.hammerAndFire(t,dt,a,4,p)] }
  ];
  function pickBoss(idx){ return Bosses[Math.min(Bosses.length-1, Math.floor(idx/10)%Bosses.length)]; }

  // ======================= GAME STATE =======================
  let game, paused=false, lastT=performance.now(), shake=0, score=0;

  function makePlayer(){
    const skin = SKINS.find(s=>s.id===save.skin) || SKINS[0];
    return {
      x: CONFIG.arena.x + CONFIG.arena.w/2,
      y: CONFIG.arena.y + CONFIG.arena.h/2,
      r: CONFIG.player.r,
      baseColor: skin.color, trail: skin.trail,
      hp: clamp(save.hp, 1, CONFIG.player.maxHP),
      iframes: 0, alive: true,
      burst: 0, burstCD: 0, shootCD: 0
    };
  }
  function makeBoss(def){
    return { name:def.name, color:def.color, hp:def.hp, maxHP:def.hp, patterns:def.patterns, time:0 };
  }

  function startRun(){
    game = {
      player: makePlayer(),
      arena: { ...CONFIG.arena },
      level: save.level|0, // 1-based
      state: isBossLevel(save.level) ? 'bossSurvive' : 'survive',
      timer: (isBossLevel(save.level) ? CONFIG.cycle.surviveSec : CONFIG.cycle.surviveSec) * 1000,
      boss: isBossLevel(save.level) ? makeBoss(pickBoss(save.level)) : null,
      bossPhaseTimer: 0,
      won: false, deathTime:0, t:0
    };
    score = save.best|0; // keep score across sessions as "run score" baseline
    clearWave();
    updateUI();
  }

  function isBossLevel(level){ return level % 10 === 0; }

  // ======================= DAMAGE/HEAL =======================
  function damagePlayer(amount){
    const p=game.player; if (!p.alive) return;
    if (p.iframes>0) return;
    p.hp -= amount; p.iframes = CONFIG.player.iframes;
    shake = Math.max(shake, CONFIG.player.dmgShake);
    tone(120,0.08,'sawtooth');
    if (p.hp<=0){ p.alive=false; p.hp=0; game.deathTime=game.t; }
    save.hp = Math.max(0, Math.ceil(p.hp)); persist();
    updateUI();
  }
  function damageBoss(amount){
    if (!game.boss) return;
    game.boss.hp = Math.max(0, game.boss.hp - amount);
    if (game.boss.hp<=0 && !game.won){
      onBossDefeated();
    }
  }
  function onBossDefeated(){
    game.won = true;
    score += 2000;
    tone(660,0.25,'triangle'); tone(880,0.25,'sine');
    // Unlock a new skin reward if available
    const locked = SKINS.map(s=>s.id).filter(id=>!save.unlocked.includes(id));
    if (locked.length){
      const award = locked[Math.floor(Math.random()*locked.length)];
      save.unlocked.push(award);
      popup(canvas.width/2, 90, 'New Skin Unlocked!', '#a6c8ff');
      popup(canvas.width/2, 110, SKINS.find(s=>s.id===award).name, '#a6c8ff');
      // auto-equip? keep current; user can press K to cycle
    }
    // advance to next level after a brief moment
    setTimeout(()=>{
      save.level = Math.max(1, (save.level|0) + 1);
      save.best = Math.max(save.best|0, Math.floor(score));
      persist();
      startRun();
    }, 900);
  }

  // ======================= LOOP =======================
  const patternState = {};
  function step(dt){
    if (paused || !game) return;
    game.t += dt;

    const a = game.arena, p = game.player;

    // input/move
    let sp = CONFIG.player.speed * (keys.ShiftLeft||keys.ShiftRight ? 1 : CONFIG.player.boost);
    let vx = (keys.ArrowRight||keys.KeyD?1:0) - (keys.ArrowLeft||keys.KeyA?1:0);
    let vy = (keys.ArrowDown||keys.KeyS?1:0) - (keys.ArrowUp||keys.KeyW?1:0);
    const len = Math.hypot(vx,vy)||1; vx/=len; vy/=len;
    p.x += vx*sp; p.y += vy*sp;
    p.x = clamp(p.x, a.x + p.r + 2, a.x + a.w - p.r - 2);
    p.y = clamp(p.y, a.y + p.r + 2, a.y + a.h - p.r - 2);
    if (p.iframes>0) p.iframes -= dt;

    // waves
    if (game.state==='survive'){
      // regular level patterns
      Patterns.corridorBeams(patternState.cb = patternState.cb||{}, dt, a, game.level);
      Patterns.crossBones(  patternState.xb = patternState.xb||{}, dt, a, game.level);
      Patterns.chaseOrbs(   patternState.co = patternState.co||{}, dt, a, game.level, p);
    } else if (game.state==='bossSurvive'){
      // boss patterns (hammers + fire)
      const patterns = game.boss.patterns;
      for (let i=0;i<patterns.length;i++){
        const key=`b_${i}`; patternState[key]=patternState[key]||{};
        patterns[i](patternState[key], dt, a, Math.max(2, Math.floor(game.level/5)), p);
      }
    } else if (game.state==='bossAttack'){
      // player shooting
      p.shootCD -= dt;
      if ((keys.Space) && p.shootCD<=0){
        p.shootCD = CONFIG.bullets.playerCooldown;
        spawnPShot(p.x, p.y-2, 0, -1);
        tone(500,0.03,'triangle');
      }
    }

    // update bullets
    for (let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      b.x += b.vx; b.y += b.vy;
      if (b.kind==='knife') b.angle += b.spin;
      if (b.kind==='fire') b.flicker = 1 - Math.random()*0.4;

      // bounds
      if (b.x<-200 || b.x>canvas.width+200 || b.y<-200 || b.y>canvas.height+200){ bullets.splice(i,1); continue; }

      let hit=false;
      if (b.kind==='rect'){ if (circleRectHit(p.x,p.y,p.r, b.x,b.y,b.w,b.h)) hit=true; }
      else if (b.kind==='knife'){ if (circleRectHit(p.x,p.y,p.r, b.x-6,b.y-8,12,16)) hit=true; }
      else if (b.kind==='orb' || b.kind==='fire'){
        if (dist2(p.x,p.y,b.x,b.y) <= (p.r+(b.r||6))*(p.r+(b.r||6))) hit=true;
        // graze
        const gR = (CONFIG.player.grazeRadius + (b.r||6) + p.r);
        if (!hit && dist2(p.x,p.y,b.x,b.y) <= gR*gR){
          score += CONFIG.player.grazeScore * dt/16;
          p.burst = clamp(p.burst + CONFIG.burst.gainPerGraze*(dt/16), 0, CONFIG.burst.max);
        }
      }
      if (hit) damagePlayer(b.dmg||8);
    }

    // hazards
    for (let i=hazards.length-1;i>=0;i--){
      const h=hazards[i];
      h.t=(h.t||0)+dt;
      if (h.kind==='beam'){
        if (h.active){
          if (circleRectHit(p.x,p.y,p.r, h.x,h.y,h.w,h.h)) damagePlayer(h.dmg);
          if (h.t>h.hold) hazards.splice(i,1);
        }
      } else if (h.kind==='hammerCol'){
        if (h.active){
          const rx = h.x - h.w/2, ry = a.y, rw = h.w, rh = a.h;
          if (circleRectHit(p.x,p.y,p.r, rx,ry,rw,rh)) damagePlayer(h.dmg);
          if (h.t>h.hold) hazards.splice(i,1);
        }
      } else if (h.kind==='hammerArc'){
        if (h.active){
          const ang = Math.atan2(p.y-h.cy, p.x-h.cx);
          const norm=(x)=>{while(x<-Math.PI)x+=2*Math.PI; while(x>Math.PI)x-=2*Math.PI; return x;};
          const A=norm(h.span.a), B=norm(h.span.b), X=norm(ang);
          const mid=norm((A+B)/2), half=Math.abs(norm(B-A))/2 + 0.2;
          const inSpan = Math.abs(norm(X-mid))<=half;
          const r2 = dist2(p.x,p.y,h.cx,h.cy);
          if (inSpan && r2 <= (h.radius+22)*(h.radius+22) && r2 >= (h.radius-38)*(h.radius-38)) damagePlayer(h.dmg);
          if (h.t>h.hold) hazards.splice(i,1);
        }
      } else if (h.kind==='fireCol'){
        if (h.active){
          if (circleRectHit(p.x,p.y,p.r, h.x-20, a.y, 40, a.h)) damagePlayer(h.dmg);
          if (h.t>h.hold) hazards.splice(i,1);
        }
      }
    }

    // telegraphs activate hazards
    for (let i=telegraphs.length-1;i>=0;i--){
      const tg=telegraphs[i]; tg.t=(tg.t||0)+dt;
      if (tg.kind==='beamWarn' && tg.t>=tg.delay){
        const b=hazards.find(h=>h.kind==='beam'&&h.x===tg.x&&h.y===tg.y&&h.w===tg.w&&h.h===tg.h&&!h.active);
        if (b){ b.active=true; b.t=0; tone(700,0.05,'square'); }
        telegraphs.splice(i,1);
      } else if (tg.kind==='hammerWarnCol' && tg.t>=tg.delay){
        const h=hazards.find(x=>x.kind==='hammerCol'&&x.x===tg.x&&!x.active);
        if (h){ h.active=true; h.t=0; tone(200,0.06,'square'); }
        telegraphs.splice(i,1);
      } else if (tg.kind==='hammerWarnArc' && tg.t>=tg.delay){
        const h=hazards.find(x=>x.kind==='hammerArc'&&x.cx===tg.cx&&x.cy===tg.cy&&!x.active);
        if (h){ h.active=true; h.t=0; tone(240,0.06,'square'); }
        telegraphs.splice(i,1);
      } else if (tg.kind==='fireWarnCol' && tg.t>=tg.delay){
        const h=hazards.find(x=>x.kind==='fireCol'&&x.x===tg.x&&!x.active);
        if (h){ h.active=true; h.t=0; tone(380,0.05,'triangle'); }
        telegraphs.splice(i,1);
      }
    }

    // player shots → boss core (boss attack only)
    for (let i=pshots.length-1;i>=0;i--){
      const s=pshots[i];
      s.x += s.vx; s.y += s.vy;
      if (game.state==='bossAttack'){
        const cx = canvas.width/2, cy = 70, r = 36;
        if (dist2(s.x,s.y,cx,cy) <= (r+2)*(r+2)){
          damageBoss(s.dmg);
          popup(s.x, s.y, `-${s.dmg}`, '#ffd6a1');
          pshots.splice(i,1); continue;
        }
      }
      if (s.y<-20 || s.x<-20 || s.x>canvas.width+20) pshots.splice(i,1);
    }

    // burst
    if (p.burstCD>0) p.burstCD -= dt;
    if (keys.KeyE && p.burst>=CONFIG.burst.max && p.burstCD<=0){
      p.burst=0; p.burstCD=CONFIG.burst.cooldown;
      if (CONFIG.burst.clearBullets){ bullets.length=0; hazards.length=0; telegraphs.length=0; }
      damageBoss(CONFIG.burst.damage);
      popup(p.x, p.y-20, 'BURST!', '#a6c8ff');
      tone(280,0.08,'sawtooth'); tone(560,0.12,'square'); tone(840,0.14,'triangle');
    }

    // timers and state transitions
    game.timer -= dt;
    if (game.state==='survive'){
      if (game.timer<=0){
        // regular level complete → next level
        levelUp();
      }
    } else if (game.state==='bossSurvive'){
      if (game.timer<=0){
        game.state='bossAttack';
        game.timer = CONFIG.cycle.attackSec*1000;
        clearWave();
      }
    } else if (game.state==='bossAttack'){
      if (game.timer<=0){
        // go back to boss survive unless boss is dead
        if (!game.won){
          game.state='bossSurvive';
          game.timer = CONFIG.cycle.surviveSec*1000;
          clearWave();
        }
      }
    }

    // score
    score += (game.state==='bossAttack'?10:6) * (dt/1000) * (1 + Math.floor((game.level-1)/10)*0.2);
    save.best = Math.max(save.best|0, Math.floor(score));

    // death
    if (!p.alive && game.t - game.deathTime > 1200){
      // On death: keep level, restore HP to max so you can try again from same level
      save.hp = CONFIG.player.maxHP;
      persist();
      startRun();
    }

    updateUI();
  }

  function levelUp(){
    // advance level; HP carries over (no auto-heal)
    save.level = Math.max(1, (save.level|0) + 1);
    persist();
    startRun();
  }

  // ======================= DRAW =======================
  let hpFlashT=0;
  function updateUI(){
    const p=game.player;
    const hpPct = Math.max(0,p.hp)/CONFIG.player.maxHP*100;
    hpFill.style.width = hpPct.toFixed(1)+'%';
    hpText.textContent = `${Math.max(0,Math.ceil(p.hp))}/${CONFIG.player.maxHP}`;
    const bPct = clamp(p.burst/CONFIG.burst.max,0,1)*100;
    burstFill.style.width = bPct.toFixed(1)+'%';
    burstText.textContent = p.burst>=CONFIG.burst.max ? 'Ready (E)' : `${Math.floor(bPct)}%`;

    lvText.textContent = `Level ${game.level}${isBossLevel(game.level)?' (Boss)':''}`;
    phaseText.textContent = game.state.replace('boss','Boss ').replace('survive','Survive').replace('Attack','Attack');
    timerText.textContent = `${Math.max(0,Math.ceil(game.timer/1000))}s`;
    scoreText.textContent = `Score ${Math.floor(score)}`;
    const skinName = (SKINS.find(s=>s.id===save.skin)||SKINS[0]).name;
    skinText.textContent = `Skin: ${skinName} (K to change)`;
  }

  function draw(){
    // bg/trail
    if (CONFIG.visual.trail){ ctx.fillStyle='rgba(0,0,0,'+CONFIG.visual.trailAlpha+')'; ctx.fillRect(0,0,canvas.width,canvas.height); }
    else { ctx.fillStyle=CONFIG.visual.bg; ctx.fillRect(0,0,canvas.width,canvas.height); }

    if (shake>0) shake -= 0.4;
    ctx.save(); ctx.translate(rand(-shake,shake), rand(-shake,shake));

    // arena
    const a = game.arena;
    ctx.strokeStyle=CONFIG.arena.color; ctx.lineWidth=CONFIG.arena.border; ctx.strokeRect(a.x,a.y,a.w,a.h);

    // boss core target (only during boss)
    if (isBossLevel(game.level)){
      const cx=canvas.width/2, cy=70, r=36;
      ctx.fillStyle = game.boss?.color || '#bbb'; ctx.globalAlpha=0.5;
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
      ctx.fillStyle='#cfe'; ctx.font='12px system-ui'; ctx.textAlign='center';
      ctx.fillText(game.boss?.name || 'Boss', cx, cy+2);
      ctx.fillText(`${Math.ceil(game.boss?.hp||0)}/${game.boss?.maxHP||0}`, cx, cy+18);
    }

    // telegraphs
    telegraphs.forEach(tg=>{
      if (tg.kind==='beamWarn'){
        ctx.fillStyle=CONFIG.visual.warn; ctx.globalAlpha=0.25 + 0.25*Math.sin((tg.t||0)/70); ctx.fillRect(tg.x,tg.y,tg.w,tg.h); ctx.globalAlpha=1;
      } else if (tg.kind==='hammerWarnCol'){
        ctx.fillStyle=CONFIG.visual.hammer; ctx.globalAlpha=0.22; ctx.fillRect(tg.x-35, a.y, 70, a.h); ctx.globalAlpha=1;
      } else if (tg.kind==='hammerWarnArc'){
        ctx.strokeStyle=CONFIG.visual.hammer; ctx.globalAlpha=0.8; ctx.lineWidth=6; ctx.beginPath(); ctx.arc(tg.cx,tg.cy,tg.radius, tg.span.a, tg.span.b); ctx.stroke(); ctx.globalAlpha=1;
      } else if (tg.kind==='fireWarnCol'){
        ctx.fillStyle=CONFIG.visual.fire; ctx.globalAlpha=0.18; ctx.fillRect(tg.x-20, a.y, 40, a.h); ctx.globalAlpha=1;
      }
    });

    // hazards
    hazards.forEach(h=>{
      if (h.kind==='beam'){ ctx.fillStyle=h.active?CONFIG.visual.beam:CONFIG.visual.warn; ctx.globalAlpha=h.active?0.6:0.25; ctx.fillRect(h.x,h.y,h.w,h.h); ctx.globalAlpha=1; }
      else if (h.kind==='hammerCol'){ if (h.active){ ctx.fillStyle=h.color; ctx.globalAlpha=0.7; ctx.fillRect(h.x-35, a.y, 70, a.h); ctx.globalAlpha=1; } }
      else if (h.kind==='hammerArc'){ if (h.active){ ctx.strokeStyle=h.color; ctx.lineWidth=10; ctx.globalAlpha=0.8; ctx.beginPath(); ctx.arc(h.cx,h.cy,h.radius,h.span.a,h.span.b); ctx.stroke(); ctx.globalAlpha=1; } }
      else if (h.kind==='fireCol'){ if (h.active){ ctx.fillStyle=h.color; ctx.globalAlpha=0.45; ctx.fillRect(h.x-20,a.y,40,a.h); ctx.globalAlpha=1; } }
    });

    // bullets
    bullets.forEach(b=>{
      if (b.kind==='rect'){ ctx.fillStyle=b.color; ctx.fillRect(b.x,b.y,b.w,b.h); }
      else if (b.kind==='knife'){ ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.angle); ctx.fillStyle=b.color; ctx.fillRect(-b.w/2,-b.h/2,b.w,b.h); ctx.restore(); }
      else if (b.kind==='orb'){ ctx.fillStyle=b.color; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
      else if (b.kind==='fire'){ ctx.fillStyle=b.color; ctx.globalAlpha=0.8*(b.flicker||1); ctx.beginPath(); ctx.arc(b.x,b.y,b.r+rand(-1,1),0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
    });

    // player shots
    pshots.forEach(s=>{ ctx.fillStyle=s.color; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); });

    // player
    const p=game.player;
    const tint = p.iframes>0 ? '#ffd6d9' : (p.baseColor||'#ff4d6d');
    ctx.fillStyle=tint; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
    if (Math.random()<0.6){ ctx.fillStyle=(p.trail||'#ffb3c1'); ctx.globalAlpha=0.5; ctx.beginPath(); ctx.arc(p.x+rand(-3,3),p.y+rand(-3,3),2,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }

    // float texts
    floatTexts.forEach(ft=>{ ft.t+=16; ft.y+=ft.vy; ctx.fillStyle=ft.color; ctx.globalAlpha=1 - ft.t/ft.life; ctx.font='12px system-ui'; ctx.textAlign='center'; ctx.fillText(ft.text, ft.x, ft.y); ctx.globalAlpha=1; });
    for (let i=floatTexts.length-1;i>=0;i--){ if (floatTexts[i].t>=floatTexts[i].life) floatTexts.splice(i,1); }

    // overlays
    ctx.fillStyle='#a9b'; ctx.textAlign='center';
    if (!p.alive){
      ctx.font='bold 26px system-ui'; ctx.fillText('You fell. Restarting level…', canvas.width/2, 56);
    } else if (game.won){
      ctx.font='bold 26px system-ui'; ctx.fillText('Boss Down! Advancing…', canvas.width/2, 56);
    }

    ctx.restore();
  }

  // ======================= INPUT =======================
  const keys={};
  window.addEventListener('keydown', e=>{
    keys[e.code]=true;
    if (e.code==='KeyP'){ paused=!paused; e.preventDefault(); }
    if (e.code==='KeyM'){ CONFIG.sfx.enabled = !CONFIG.sfx.enabled; persist(); e.preventDefault(); }
    if (e.code==='KeyK'){ cycleSkin(); e.preventDefault(); }
    if (e.code==='Space'){ e.preventDefault(); }
  });
  window.addEventListener('keyup', e=>{ keys[e.code]=false; });

  function cycleSkin(){
    const unlocked = save.unlocked.map(id=>SKINS.findIndex(s=>s.id===id)).filter(i=>i>=0).sort((a,b)=>a-b);
    const curIndex = SKINS.findIndex(s=>s.id===save.skin);
    let pos = unlocked.indexOf(curIndex);
    pos = (pos+1) % unlocked.length;
    save.skin = SKINS[unlocked[pos]].id;
    // Immediately apply
    if (game && game.player){
      const skin = SKINS.find(s=>s.id===save.skin) || SKINS[0];
      game.player.baseColor = skin.color; game.player.trail = skin.trail;
    }
    persist(); updateUI();
  }

  // ======================= MAIN LOOP =======================
  function loop(){
    const t = performance.now();
    const dt = clamp(t - lastT, 0, 40);
    lastT = t;
    if (!game) startRun();
    step(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // auto-start
  startRun();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>

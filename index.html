<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Bullet Heart Run — Waterfall Chaos</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<style>
  :root{
    --fg:#e7e7ef; --bg:#0b0b10; --ui:#3a3a5d; --ui2:#191924;
    --hp:#7affb7; --tp:#6cb6ff; --warn:#ffd166;
    --white:#ffffff; --green:#57ff9b; --knife:#efc7b6; --bone:#e5e5ff; --beam:#73c0ff; --fire:#ff6b3d;
    --boss:#ffd2ae;
  }
  html,body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
  #wrap{display:flex;flex-direction:column;align-items:center;gap:10px;padding:12px;}
  .hud{width:980px;max-width:96vw;display:flex;justify-content:space-between;align-items:center;}
  canvas{background:#000;border:2px solid var(--fg);image-rendering:pixelated;touch-action:none;}
  button{background:var(--ui2);color:var(--fg);border:1px solid var(--ui);padding:6px 10px;cursor:pointer;}
  button:hover{background:#20203a;}
  .bar{height:10px;background:#23233a;border:1px solid var(--ui);width:240px}
  .fill{height:100%;background:var(--tp)}
  .green .fill{background:var(--hp)}
  .pill{padding:4px 8px;border:1px solid var(--ui);border-radius:999px}
  .small{font-size:12px;opacity:.85}
  dialog{border:1px solid var(--ui);background:#12121a;color:var(--fg);padding:14px;max-width:92vw}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:6px 0}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:10px}
  .card{border:1px solid var(--ui);padding:10px;background:#141422;cursor:pointer}
  .card:hover{background:#1a1a2a}
</style>
</head>
<body>
<div id="wrap">
  <div class="hud">
    <span>Move: WASD/Arrows • Shoot: Space • Dash: Shift • Wind Charge: E • Ability: Q • Pause: P • Reset: R</span>
    <div style="display:flex;gap:8px">
      <button id="pauseBtn">Pause</button>
      <button id="resetBtn">Reset</button>
    </div>
  </div>

  <canvas id="game" width="980" height="700"></canvas>

  <div class="hud">
    <div style="display:flex;gap:10px;align-items:center">
      <span>HP</span>
      <div class="bar green" style="width:220px"><div id="hpFill" class="fill" style="width:100%"></div></div>
      <span id="hpText"></span>
    </div>
    <div style="display:flex;gap:10px;align-items:center">
      <span>Wind</span>
      <div class="bar" style="width:220px"><div id="tpFill" class="fill" style="width:0%"></div></div>
      <span id="tpText"></span>
    </div>
    <div style="display:flex;gap:10px;align-items:center">
      <span class="pill" id="lvText"></span>
      <span class="pill" id="phaseText"></span>
      <span class="pill" id="timerText"></span>
      <span class="pill" id="dashText"></span>
      <span class="pill" id="abilText"></span>
      <span class="pill" id="enemyText"></span>
    </div>
  </div>

  <div class="small">Waterfall attacks: fast falling barrages, spirals, pulses. Normal enemies + bosses every 5 levels. Shoot always. Easier start, fair but intense.</div>
</div>

<!-- Upgrades -->
<dialog id="upgradeDlg">
  <div style="font-weight:700;margin-bottom:8px">Choose an upgrade</div>
  <div class="grid" id="upgrid"></div>
  <div class="row" style="justify-content:flex-end">
    <button id="skipUpg">Skip</button>
  </div>
</dialog>

<!-- Ability info -->
<dialog id="infoDlg">
  <div style="font-weight:700;margin-bottom:8px">Ability unlocked</div>
  <div id="infoBody" style="opacity:.9"></div>
  <div class="row" style="justify-content:flex-end">
    <button id="infoOk">Got it</button>
  </div>
</dialog>

<script>
(() => {
  'use strict';

  // ================= CONFIG =================
  const CFG = {
    arena: { x: 170, y: 120, w: 640, h: 460, border: 3, color: '#c9c9ff' },
    player: { r: 8, speed: 3.1, boost: 1.15, iframes: 900, baseMaxHP: 95, grazeR: 22, dashI: 520, dashCD: 1500, dashDist: 140 },
    cycle: { wave: 22_000 }, // time to clear enemies or survive
    bullets: { pSpeed: 7.2, pCD: 90, pDmg: 10 },
    wind: { max: 100, graze: 0.34, proxR: 110, proxPS: 0.12, passPS: 0.05, capPS: 10, dmg: 150, clear: true, push: 2.4, dur: 1600, cd: 3000, lock: 700 },
    saveKey: 'bhr_wc_enemies_v1'
  };

  // ================= DOM =================
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hpFill = document.getElementById('hpFill'), hpText = document.getElementById('hpText');
  const tpFill = document.getElementById('tpFill'), tpText = document.getElementById('tpText');
  const lvText = document.getElementById('lvText'), phaseText = document.getElementById('phaseText');
  const timerText = document.getElementById('timerText'), dashText = document.getElementById('dashText');
  const abilText = document.getElementById('abilText'), enemyText = document.getElementById('enemyText');
  const pauseBtn = document.getElementById('pauseBtn'), resetBtn = document.getElementById('resetBtn');
  const upDlg = document.getElementById('upgradeDlg'), upGrid = document.getElementById('upgrid'), skipUpg = document.getElementById('skipUpg');
  const infoDlg = document.getElementById('infoDlg'), infoBody = document.getElementById('infoBody'), infoOk = document.getElementById('infoOk');

  // ================= SAVE =================
  function loadSave(){
    try{
      const raw = localStorage.getItem(CFG.saveKey);
      if (!raw) return {
        level:1, hp:CFG.player.baseMaxHP, upg:{ hp:0, speed:0, windMax:0, windPow:0, dash:0, fire:0 },
        abil:{ blink:false, pulse:false }, info:{ blink:false, pulse:false }
      };
      const s = JSON.parse(raw);
      s.level = Math.max(1, Math.min(50, s.level|0));
      s.hp = Math.max(1, Math.min(999, s.hp|0));
      s.upg = Object.assign({ hp:0, speed:0, windMax:0, windPow:0, dash:0, fire:0 }, s.upg||{});
      s.abil = Object.assign({ blink:false, pulse:false }, s.abil||{});
      s.info = Object.assign({ blink:false, pulse:false }, s.info||{});
      return s;
    }catch(e){
      return { level:1, hp:CFG.player.baseMaxHP, upg:{ hp:0, speed:0, windMax:0, windPow:0, dash:0, fire:0 }, abil:{ blink:false, pulse:false }, info:{ blink:false, pulse:false } };
    }
  }
  function persist(){
    try{
      localStorage.setItem(CFG.saveKey, JSON.stringify({
        level: save.level, hp: Math.ceil(game?.p?.hp ?? save.hp),
        upg: save.upg, abil: save.abil, info: save.info
      }));
    }catch(e){}
  }
  function hardReset(){
    save = { level:1, hp:CFG.player.baseMaxHP, upg:{ hp:0, speed:0, windMax:0, windPow:0, dash:0, fire:0 }, abil:{ blink:false, pulse:false }, info:{ blink:false, pulse:false } };
    persist(); startRun();
  }
  let save = loadSave();

  // ================= UTIL =================
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a + Math.random()*(b-a);
  const randi=(a,b)=>Math.floor(a + Math.random()*(b-a+1));
  const dist2=(x1,y1,x2,y2)=>{const dx=x2-x1,dy=y2-y1;return dx*dx+dy*dy;};
  const circleRectHit=(cx,cy,r, rx,ry,rw,rh)=>{const nx=clamp(cx,rx,rx+rw),ny=clamp(cy,ry,ry+rh);const dx=cx-nx,dy=cy-ny;return dx*dx+dy*dy<=r*r;};

  // ================= ENTITIES =================
  const bullets=[], telegraphs=[], pshots=[], floatTexts=[], pickups=[], enemies=[];
  function clearAll(){ bullets.length=0; telegraphs.length=0; pshots.length=0; floatTexts.length=0; pickups.length=0; enemies.length=0; }
  function popup(x,y,text,color='#a6c8ff'){ floatTexts.push({x,y,vy:-0.4,t:0,life:1100,text,color}); }

  // bullets
  function orb(x,y,vx,vy,r=5,dmg=5,color='#ffffff',ttl=10_000){ bullets.push({kind:'orb',x,y,vx,vy,r,dmg,color,ttl}); }
  function homing(x,y,vx,vy,r=5,dmg=6,color='#57ff9b',ttl=10_000){ bullets.push({kind:'homing',x,y,vx,vy,r,dmg,color,ttl,homing:true}); }
  function rectb(x,y,w,h,vx,vy,dmg=6,color='#e5e5ff'){ bullets.push({kind:'rect',x,y,w,h,vx,vy,dmg,color}); }
  function knife(x,y,ang,spd=3.2,dmg=6,color='#efc7b6'){ bullets.push({kind:'knife',x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,w:6,h:16,angle:ang,spin:0.2,dmg,color}); }
  function beamWarn(x,y,w,h,delay=500,hold=700,dmg=8,color='#73c0ff'){ telegraphs.push({kind:'beamWarn',x,y,w,h,t:0,delay,hold,dmg,color}); }

  // pickups
  function drop(kind,x,y){ pickups.push({kind,x,y,vx:rand(-0.3,0.3),vy:rand(0.2,0.6),t:0}); }

  // player shot
  function pshot(x,y,dx,dy){
    const sp=CFG.bullets.pSpeed*(1+0.08*save.upg.fire), n=Math.hypot(dx,dy)||1;
    pshots.push({x,y,vx:dx/n*sp,vy:dy/n*sp,r:3,color:'#c0ff7a',dmg:CFG.bullets.pDmg + save.upg.fire*3});
  }

  // enemies
  function spawnEnemy(kind, name, hp, x, y, ai){
    enemies.push({kind, name, hp, maxHP:hp, x, y, r:12, ai, t:0, dead:false, color:'#cfd', boss:false});
  }
  function spawnBoss(name, hp, x, y, ai, color='#ffd2ae'){
    enemies.push({kind:'boss', name, hp, maxHP:hp, x, y, r:18, ai, t:0, dead:false, color, boss:true});
  }

  // ================= GAME STATE =================
  const keys=new Set();
  let game, paused=false, lockUntil=0, last=performance.now(), shake=0;

  function maxHP(){ return CFG.player.baseMaxHP + save.upg.hp*12; }
  function windMax(){ return CFG.wind.max + save.upg.windMax*25; }

  function makePlayer(){
    return { x: CFG.arena.x+CFG.arena.w/2, y: CFG.arena.y+CFG.arena.h/2,
      r:8, color:'#ff485a', hp: clamp(save.hp,1,maxHP()), ifr:0, alive:true,
      wind:0, wCD:0, wT:0, wAct:false, tpAcc:0, tpTick:0, dCD:0, aCD:0,
      sCD:0, ability:'none'
    };
  }

  function startRun(){
    const lvl = save.level|0;
    game = { lvl, a:{...CFG.arena}, p:makePlayer(), t:0, timer: CFG.cycle.wave, won:false };
    // ability unlocks
    if (lvl===4 && !save.abil.blink){ save.abil.blink=true; if (!save.info.blink){ info('Blink: Q to short-teleport with brief invulnerability.', 'blink'); } }
    if (lvl===9 && !save.abil.pulse){ save.abil.pulse=true; if (!save.info.pulse){ info('Shield Pulse: Q clears nearby bullets around you.', 'pulse'); } }
    game.p.ability = save.abil.pulse ? 'pulse' : (save.abil.blink ? 'blink' : 'none');

    clearAll();
    buildWave(lvl);
    updateUI();
  }

  // ================= WAVES =================
  function buildWave(lvl){
    const a=game.a, cx=a.x+a.w/2, top=a.y-30, bot=a.y+a.h+30;
    const easy = Math.floor((lvl-1)/5);
    // normal enemies
    if (!isBoss(lvl)){
      // 3 themed enemies per wave
      spawnEnemy('specter','Spectral Bone', 60+easy*20, rand(a.x+40,a.x+a.w-40), a.y+80, AI_boneRain);
      spawnEnemy('dancer','Knife Dancer', 50+easy*18, rand(a.x+40,a.x+a.w-40), a.y+200, AI_knifeSpiral);
      spawnEnemy('swarm','Orb Swarm',     55+easy*20, rand(a.x+40,a.x+a.w-40), a.y+320, AI_greenVortex);
    } else {
      // boss with multi-phase AI
      const bossDefs = [
        {name:'Hammer Saint', hp: 480+easy*220, color:'#ffd2ae', ai:AI_bossSaint},
        {name:'Forge Warden', hp: 540+easy*250, color:'#ffb38f', ai:AI_bossWarden},
        {name:'Anvil Sovereign', hp: 620+easy*280, color:'#ffcaa1', ai:AI_bossSov},
        {name:'Pyre Regent', hp: 700+easy*320, color:'#ff9f7a', ai:AI_bossPyre},
        {name:'Caldera Monarch', hp: 800+easy*360, color:'#ffa86b', ai:AI_bossCaldera}
      ];
      const bd = bossDefs[Math.min(4, Math.floor((lvl-1)/10))];
      spawnBoss(bd.name, bd.hp, cx, a.y+160, bd.ai, bd.color);
    }
  }
  const isBoss = lvl=>lvl%5===0;

  // ================= AI PATTERNS =================
  // Waterfall: fast downward barrages + creative twists

  // 1) Bone Rain (specter) — staggered falling bones like a waterfall
  function AI_boneRain(e, dt, a, p, power){
    e.t += dt;
    // move horizontally slowly
    e.x += Math.sin(e.t/700)*0.8;
    // spawn fast falling bones frequently
    if (!e.last || e.t - e.last > Math.max(220, 520 - 40*power)){
      e.last = e.t;
      for (let i=0;i<3;i++){
        const x = rand(a.x+20, a.x+a.w-20);
        rectb(x, a.y-18, 18, 10, 0, 2.2+0.15*power, 6, '#e5e5ff');
      }
    }
    // occasional diagonal bones (angled rain)
    if (!e.lastD || e.t - e.lastD > Math.max(600, 1000 - 60*power)){
      e.lastD = e.t;
      const x = rand(a.x+30, a.x+a.w-30), ang = Math.PI*0.5 + rand(-0.35,0.35);
      const vx = Math.cos(ang)*(1.6+0.1*power), vy = Math.sin(ang)*(2.2+0.14*power);
      rectb(x, a.y-22, 16, 10, vx, vy, 7, '#e5e5ff');
    }
  }

  // 2) Knife Spiral (dancer) — rotating spiral that descends
  function AI_knifeSpiral(e, dt, a, p, power){
    e.t += dt; e.ang = (e.ang||0) + dt*0.005*(1+0.1*power);
    const cx = e.x, cy = e.y;
    if (!e.last || e.t - e.last > Math.max(260, 520 - 50*power)){
      e.last = e.t;
      const count = 6 + Math.min(8, power*2);
      for (let i=0;i<count;i++){
        const ang = e.ang + i*(Math.PI*2)/count;
        knife(cx, cy, ang + Math.PI*0.5, 2.6+0.14*power, 7, '#efc7b6');
      }
    }
    // gently drift down like a falling spinner
    e.y += (0.6 + 0.08*power);
    if (e.y > a.y + a.h - 40) e.y = a.y + 140;
  }

  // 3) Green Vortex (swarm) — rotating ring + homing dives
  function AI_greenVortex(e, dt, a, p, power){
    e.t += dt; e.ang = (e.ang||0) + dt*0.004*(1+0.12*power);
    const ringR = 90 + 6*power;
    if (!e.last || e.t - e.last > Math.max(240, 480 - 40*power)){
      e.last = e.t;
      const n = 8 + Math.min(8, power*2);
      for (let i=0;i<n;i++){
        const ang = e.ang + i*(Math.PI*2)/n;
        const x = e.x + Math.cos(ang)*ringR;
        const y = e.y + Math.sin(ang)*ringR;
        const side = ang + Math.PI/2;
        // alternate white and green; greens home hard
        if (i%2===0) orb(x,y, Math.cos(side)*1.6, Math.sin(side)*1.6 + 1.4, 5, 5, '#ffffff', 10000);
        else homing(x,y, Math.cos(side)*1.4, Math.sin(side)*1.4 + 1.6, 5, 6, '#57ff9b', 10000);
      }
    }
    // drift downwards — waterfall feeling
    e.y += (0.5 + 0.1*power);
    if (e.y > a.y + a.h - 60) e.y = a.y + 120;
  }

  // Boss AIs: phase shifts mixing the above + beams/hammer arcs (telegraphed)
  function AI_bossSaint(e, dt, a, p, power){ // slams + arcs + bone rain
    e.t += dt; const phase = (e.t/4000|0)%3;
    if (phase===0) AI_boneRain(e, dt, a, p, power+1);
    if (phase===1) hammerArcs(e, dt, a, p, power);
    if (phase===2) knifeFlood(e, dt, a, p, power);
  }
  function AI_bossWarden(e, dt, a, p, power){ // beams + vortex
    e.t += dt; const phase = (e.t/3500|0)%3;
    if (phase===0) beamPulses(e, dt, a, p, power);
    if (phase===1) AI_greenVortex(e, dt, a, p, power+1);
    if (phase===2) fireFalls(e, dt, a, p, power);
  }
  function AI_bossSov(e, dt, a, p, power){ e.t+=dt; boneCurtains(e,dt,a,p,power); }
  function AI_bossPyre(e, dt, a, p, power){ e.t+=dt; fireFalls(e,dt,a,p,power+1); beamPulses(e,dt,a,p,power); }
  function AI_bossCaldera(e, dt, a, p, power){ e.t+=dt; knifeFlood(e,dt,a,p,power+1); hammerArcs(e,dt,a,p,power+1); }

  // Helpers: creative sub-patterns
  function hammerArcs(e,dt,a,p,power){
    e.arcT=(e.arcT||0)+dt;
    if (e.arcT>900){
      e.arcT=0;
      const cx=a.x+a.w/2, cy=a.y+a.h/2, span=Math.PI/3 + 0.08*power, ang=Math.atan2(p.y-cy,p.x-cx);
      telegraphs.push({kind:'arc',cx,cy,r:160+10*power, a:ang-span/2, b:ang+span/2, t:0, delay:520, hold:520, dmg:9, color:'#ff9d6c'});
    }
  }
  function knifeFlood(e,dt,a,p,power){
    e.kT=(e.kT||0)+dt;
    if (e.kT>220){
      e.kT=0;
      const cx=e.x, cy=e.y, count=10+power*2;
      for (let i=0;i<count;i++){
        const ang = (i/count)*Math.PI*2 + (e.t/700);
        knife(cx,cy,ang+Math.PI*0.5, 3.1+0.2*power, 7, '#efc7b6');
      }
    }
  }
  function beamPulses(e,dt,a,p,power){
    e.bT=(e.bT||0)+dt;
    if (e.bT>Math.max(300, 700-60*power)){
      e.bT=0;
      const vertical = Math.random()<0.8; // more vertical for waterfall vibe
      if (vertical){
        const x = randi(a.x+40, a.x+a.w-40);
        beamWarn(x,a.y,8,a.h, 520-30*power, 560, 8, '#73c0ff');
      } else {
        const y = randi(a.y+40, a.y+a.h-40);
        beamWarn(a.x,y,a.w,8, 520-30*power, 560, 8, '#73c0ff');
      }
    }
  }
  function fireFalls(e,dt,a,p,power){
    e.fT=(e.fT||0)+dt;
    if (e.fT>240){
      e.fT=0;
      const x=randi(a.x+20,a.x+a.w-20), vy=2.6+0.18*power;
      orb(x, a.y-16, 0, vy, 6, 7, '#ff6b3d', 10000);
    }
  }
  function boneCurtains(e,dt,a,p,power){
    e.cT=(e.cT||0)+dt;
    if (e.cT>280){
      e.cT=0;
      const gap=90, lanes=5, laneW=a.w/lanes;
      const open = randi(0, lanes-1);
      for (let i=0;i<lanes;i++){
        if (i===open) continue;
        const x=a.x+i*laneW + laneW/2;
        rectb(x, a.y-18, 18,10, 0,2.3+0.14*power, 7, '#e5e5ff');
      }
    }
  }

  // ================= LOOP =================
  function step(dt){
    if (!game || paused) return;
    game.t += dt; const a=game.a; const p=game.p;

    // timers
    game.timer -= dt;
    if (game.timer<=0 || (enemies.length===0 && bullets.length===0 && telegraphs.length===0)){
      // win wave
      save.level = Math.min(50, save.level+1);
      // small heal and select upgrade every 2 levels
      heal(8 + save.upg.hp*2);
      if (save.level % 2 === 0) showUpgrade();
      persist(); startRun(); return;
    }

    // input
    let vx = (isDown('KeyD')||isDown('ArrowRight')?1:0) - (isDown('KeyA')||isDown('ArrowLeft')?1:0);
    let vy = (isDown('KeyS')||isDown('ArrowDown')?1:0) - (isDown('KeyW')||isDown('ArrowUp')?1:0);
    const len=Math.hypot(vx,vy)||1; vx/=len; vy/=len;
    const mv = (CFG.player.speed + save.upg.speed*0.22) * (keys.has('ShiftLeft')||keys.has('ShiftRight') ? 1 : CFG.player.boost);
    p.x = clamp(p.x + vx*mv, a.x+p.r+2, a.x+a.w-p.r-2);
    p.y = clamp(p.y + vy*mv, a.y+p.r+2, a.y+a.h-p.r-2);
    if (p.ifr>0) p.ifr -= dt;

    // dash
    if ((wasPressed('ShiftLeft')||wasPressed('ShiftRight')) && p.dCD<=0){
      const dist = CFG.player.dashDist + save.upg.dash*10;
      p.x = clamp(p.x + vx*dist, a.x+p.r+2, a.x+a.w-p.r-2);
      p.y = clamp(p.y + vy*dist, a.y+p.r+2, a.y+a.h-p.r-2);
      p.ifr = Math.max(p.ifr, CFG.player.dashI);
      p.dCD = Math.max(480, CFG.player.dashCD - save.upg.dash*120);
    }
    if (p.dCD>0) p.dCD -= dt;

    // ability Q
    if (wasPressed('KeyQ') && p.aCD<=0 && p.ability!=='none'){
      if (p.ability==='blink'){
        const dist=120 + save.upg.speed*8;
        p.x = clamp(p.x + vx*dist, a.x+p.r+2, a.x+a.w-p.r-2);
        p.y = clamp(p.y + vy*dist, a.y+p.r+2, a.y+a.h-p.r-2);
        p.ifr = Math.max(p.ifr, 260);
        p.aCD = 5000;
      } else if (p.ability==='pulse'){
        for (let i=bullets.length-1;i>=0;i--) if (dist2(p.x,p.y,bullets[i].x,bullets[i].y)<=130*130) bullets.splice(i,1);
        p.aCD = 8000;
      }
    }
    if (p.aCD>0) p.aCD -= dt;

    // shooting (always)
    p.sCD -= dt;
    if (isDown('Space') && p.sCD<=0){
      p.sCD = CFG.bullets.pCD;
      pshot(p.x, p.y-2, 0, -1);
    }

    // enemies AI and collisions
    for (let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      e.t += dt;
      const power = Math.floor((game.lvl-1)/5)+1;
      e.ai(e, dt, a, p, power);
      // enemy bullets collide with player
      // handled in bullet loop
      // shots -> enemy
    }

    // bullets update
    for (let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      if (b.ttl!=null){ b.ttl-=dt; if (b.ttl<=0){ bullets.splice(i,1); continue; } }
      // homing behavior + waterfall acceleration
      if (b.kind==='homing'){
        const desire = Math.atan2(p.y-b.y,p.x-b.x);
        b.vx = b.vx*0.92 + 0.24*Math.cos(desire);
        b.vy = b.vy*0.92 + 0.28*Math.sin(desire) + 0.06; // gravity-like pull
      } else {
        // gentle gravity for waterfall feel
        b.vy = (b.vy||0) + 0.01;
      }
      if (b.kind==='knife') b.angle += b.spin;
      b.x += b.vx; b.y += b.vy;

      // bounds
      if (b.x<-260||b.x>canvas.width+260||b.y<-260||b.y>canvas.height+260){ bullets.splice(i,1); continue; }

      // collide with player
      let hit=false;
      if (b.kind==='rect'){ hit = circleRectHit(p.x,p.y,p.r, b.x,b.y,b.w,b.h); }
      else if (b.kind==='knife'){ hit = circleRectHit(p.x,p.y,p.r, b.x-6,b.y-8,12,16); }
      else { const rr=(b.r||5)+p.r; if (dist2(p.x,p.y,b.x,b.y)<=rr*rr) hit=true; }
      if (hit) dmgPlayer(b.dmg||6);

      // graze wind
      const gR=CFG.player.grazeR + (b.r||5) + p.r;
      if (dist2(p.x,p.y,b.x,b.y)<=gR*gR && performance.now()>=lockUntil) addWind(dt);
    }

    // telegraphs -> beams/arcs activation
    for (let i=telegraphs.length-1;i>=0;i--){
      const t=telegraphs[i]; t.t+=dt;
      if (t.kind==='beamWarn' && t.t>=t.delay){
        // activate for hold duration: we track inline using copy
        bullets.push({kind:'beam',x:t.x,y:t.y,w:t.w,h:t.h, t:0, hold:t.hold, dmg:t.dmg, color:t.color});
        telegraphs.splice(i,1);
      } else if (t.kind==='arc' && t.t>=t.delay){
        bullets.push({kind:'arc',cx:t.cx,cy:t.cy,r:t.r,a:t.a,b:t.b,t:0,hold:t.hold,dmg:t.dmg,color:t.color});
        telegraphs.splice(i,1);
      }
    }

    // beam/arc active hazards tick
    for (let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      if (b.kind==='beam'){
        b.t+=dt; // collide as rect
        if (circleRectHit(p.x,p.y,p.r, b.x,b.y,b.w,b.h)) dmgPlayer(b.dmg||8);
        if (b.t>b.hold) bullets.splice(i,1);
      } else if (b.kind==='arc'){
        b.t+=dt;
        // ring segment collision
        const ang = Math.atan2(p.y-b.cy, p.x-b.cx);
        const norm=x=>{while(x<-Math.PI)x+=2*Math.PI;while(x>Math.PI)x-=2*Math.PI;return x;};
        const mid=norm((b.a+b.b)/2), half=Math.abs(norm(b.b-b.a))/2 + 0.18;
        const inSpan = Math.abs(norm(ang-mid))<=half;
        const d2=dist2(p.x,p.y,b.cx,b.cy);
        if (inSpan && d2<=(b.r+22)**2 && d2>=(b.r-34)**2) dmgPlayer(b.dmg||9);
        if (b.t>b.hold) bullets.splice(i,1);
      }
    }

    // shots -> enemies
    for (let i=pshots.length-1;i>=0;i--){
      const s=pshots[i]; s.x+=s.vx; s.y+=s.vy;
      let hitAny=false;
      for (let j=enemies.length-1;j>=0;j--){
        const e=enemies[j];
        if (dist2(s.x,s.y,e.x,e.y) <= (e.r+3)**2){
          e.hp = Math.max(0, e.hp - s.dmg);
          popup(e.x, e.y-16, `-${s.dmg}`, '#ffd6a1');
          hitAny=true;
          if (e.hp<=0 && !e.dead){
            e.dead=true; enemies.splice(j,1);
            // drops
            drop('heal', e.x, e.y); if (e.boss) { drop('heal', e.x+16, e.y); drop('force', e.x-16, e.y); }
          }
          break;
        }
      }
      if (hitAny || s.y<-30 || s.x<-30 || s.x>canvas.width+30) pshots.splice(i,1);
    }

    // pickups
    for (let i=pickups.length-1;i>=0;i--){
      const pk=pickups[i]; pk.t=(pk.t||0)+dt; pk.x+=pk.vx; pk.y+=pk.vy*0.98; pk.vy+=0.01;
      const a=game.a;
      if (pk.x<a.x+6){ pk.x=a.x+6; pk.vx*=-0.5; }
      if (pk.x>a.x+a.w-6){ pk.x=a.x+a.w-6; pk.vx*=-0.5; }
      if (pk.y>a.y+a.h-8){ pk.y=a.y+a.h-8; pk.vy*=-0.5; }
      if (dist2(p.x,p.y,pk.x,pk.y) <= (p.r+10)*(p.r+10)){
        if (pk.kind==='heal') heal(16);
        else if (pk.kind==='force') forceField(12000);
        pickups.splice(i,1); continue;
      }
      if (pk.t>12000) pickups.splice(i,1);
    }

    // wind charge gain (proximity)
    if (performance.now()>=lockUntil){
      p.tpTick += dt; if (p.tpTick>=1000){ p.tpAcc=0; p.tpTick=0; }
      // consider proximity to active beams or many bullets
      let near=false;
      const pr2=CFG.wind.proxR*CFG.wind.proxR;
      for (let b of bullets){
        if (b.kind==='beam'){ const hx=clamp(p.x,b.x,b.x+b.w), hy=clamp(p.y,b.y,b.y+b.h); if (dist2(p.x,p.y,hx,hy)<=pr2){ near=true; break; } }
      }
      const gain = Math.min(CFG.wind.capPS - p.tpAcc, Math.max(0, (near?CFG.wind.proxPS:0)*(dt/1000) + CFG.wind.passPS*(dt/1000)));
      p.tpAcc += Math.max(0,gain||0);
      p.wind = clamp(p.wind + Math.max(0,gain||0), 0, windMax());
    }

    // wind use
    if (wasPressed('KeyE') && performance.now()>=lockUntil && p.wCD<=0 && p.wind>=windMax()){
      p.wind=0; p.wCD=CFG.wind.cd; p.wAct=true; p.wT=CFG.wind.dur; p.ifr=Math.max(p.ifr,CFG.wind.dur);
      if (CFG.wind.clear){ bullets.length=bullets.filter(b=>!(b.kind==='orb'||b.kind==='homing'||b.kind==='knife'||b.kind==='rect')).length; }
      // push and damage nearby enemies a bit
      enemies.forEach(e=>{
        const dx=e.x-p.x, dy=e.y-p.y, d=Math.max(1, Math.hypot(dx,dy));
        e.x += (dx/d)*26; e.y += (dy/d)*26;
        e.hp = Math.max(0, e.hp - (CFG.wind.dmg*0.15 + save.upg.windPow*8));
      });
    }
    if (p.wCD>0) p.wCD -= dt;
    if (p.wAct){ p.wT-=dt; if (p.wT<=0) p.wAct=false; }

    // death -> retry same level
    if (!p.alive && game.t - (game.deathT||0) > 800){
      save.hp = maxHP(); persist(); startRun();
    }

    updateUI();
  }

  // ================= DAMAGE/HEAL =================
  function dmgPlayer(d){
    const p=game.p; if (!p.alive) return; if (p.wAct) return; if (p.ifr>0) return;
    p.hp -= d; p.ifr = CFG.player.iframes; shake = Math.max(shake, 3.5);
    if (p.hp<=0){ p.hp=0; p.alive=false; game.deathT=game.t; }
    save.hp = Math.max(0, Math.ceil(p.hp)); persist(); updateUI();
  }
  function heal(n){
    const p=game.p; const before=p.hp; p.hp = clamp(p.hp+n, 0, maxHP());
    if (p.hp>before) popup(p.x,p.y-14, `+${Math.ceil(p.hp-before)}`, '#7affb7');
    save.hp = Math.ceil(p.hp); persist(); updateUI();
  }
  function forceField(ms){ const p=game.p; p.ifr = Math.max(p.ifr, ms); popup(p.x,p.y-14,'Force Field','#a1d8ff'); }

  // ================= UI =================
  function updateUI(){
    const p=game.p, lvl=game.lvl;
    hpFill.style.width = (Math.max(0,p.hp)/maxHP()*100).toFixed(1)+'%';
    hpText.textContent = `${Math.max(0,Math.ceil(p.hp))}/${maxHP()}`;
    const wPct = Math.max(0, Math.min(1, p.wind/windMax()))*100;
    tpFill.style.width = wPct.toFixed(1)+'%';
    tpText.textContent = p.wind>=windMax() ? 'Ready (E)' : `${Math.floor(wPct)}%`;
    lvText.textContent = `Level ${lvl}${isBoss(lvl)?' (Boss)':''}`;
    phaseText.textContent = `${isBoss(lvl)?'Boss fight':'Wave'}`;
    timerText.textContent = `${Math.max(0,Math.ceil(game.timer/1000))}s`;
    dashText.textContent = `Dash ${Math.max(0,Math.ceil((game.p.dCD||0)/1000))}s`;
    const abilName = game.p.ability==='none'?'—':game.p.ability;
    abilText.textContent = `Ability: ${abilName} ${Math.max(0,Math.ceil((game.p.aCD||0)/1000))}s`;
    if (enemies.length){
      const boss = enemies.find(e=>e.boss);
      const label = boss ? `${boss.name} ${Math.ceil(boss.hp)}/${boss.maxHP}` : `${enemies.length} enemies`;
      enemyText.textContent = label;
    } else enemyText.textContent = '—';
  }

  function draw(){
    // bg hue by block
    const block=Math.floor((game.lvl-1)/5), hues=[200, 25, 260, 120], hue=hues[block%hues.length];
    const grad=ctx.createLinearGradient(0,0,canvas.width,0);
    grad.addColorStop(0, `hsl(${hue},35%,10%)`); grad.addColorStop(1, `hsl(${(hue+60)%360},35%,8%)`);
    ctx.fillStyle=grad; ctx.fillRect(0,0,canvas.width,canvas.height);

    if (shake>0) shake-=0.3;
    ctx.save(); ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);

    const a=game.a;
    ctx.strokeStyle='#c9c9ff'; ctx.lineWidth=a.border; ctx.strokeRect(a.x,a.y,a.w,a.h);

    // telegraphs
    telegraphs.forEach(t=>{
      if (t.kind==='beamWarn'){
        ctx.fillStyle='#ffd166'; ctx.globalAlpha=0.28; ctx.fillRect(t.x,t.y,t.w,t.h); ctx.globalAlpha=1;
      } else if (t.kind==='arc'){
        ctx.strokeStyle='#ff9d6c'; ctx.lineWidth=6; ctx.globalAlpha=0.8; ctx.beginPath(); ctx.arc(t.cx,t.cy,t.r,t.a,t.b); ctx.stroke(); ctx.globalAlpha=1;
      }
    });

    // bullets
    bullets.forEach(b=>{
      if (b.kind==='rect'){ ctx.fillStyle=b.color; ctx.fillRect(b.x,b.y,b.w,b.h); }
      else if (b.kind==='knife'){ ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.angle); ctx.fillStyle=b.color; ctx.fillRect(-b.w/2,-b.h/2,b.w,b.h); ctx.restore(); }
      else if (b.kind==='beam'){ ctx.fillStyle=b.color; ctx.globalAlpha=0.6; ctx.fillRect(b.x,b.y,b.w,b.h); ctx.globalAlpha=1; }
      else if (b.kind==='arc'){ ctx.strokeStyle=b.color; ctx.lineWidth=10; ctx.globalAlpha=0.8; ctx.beginPath(); ctx.arc(b.cx,b.cy,b.r,b.a,b.b); ctx.stroke(); ctx.globalAlpha=1; }
      else { ctx.fillStyle=b.color; ctx.beginPath(); ctx.arc(b.x,b.y,b.r||5,0,Math.PI*2); ctx.fill(); }
    });

    // enemies
    enemies.forEach(e=>{
      ctx.fillStyle = e.boss? '#ffd2ae' : e.color;
      ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill();
      // tiny hp bar
      const w=40, hpw = Math.max(0, e.hp/e.maxHP)*w;
      ctx.fillStyle='#222'; ctx.fillRect(e.x-w/2, e.y-e.r-10, w, 4);
      ctx.fillStyle='#7affb7'; ctx.fillRect(e.x-w/2, e.y-e.r-10, hpw, 4);
      ctx.fillStyle='#cfe'; ctx.font='11px system-ui'; ctx.textAlign='center';
      ctx.fillText(e.boss?e.name: e.name, e.x, e.y-e.r-16);
    });

    // pickups
    pickups.forEach(pk=>{
      ctx.fillStyle = pk.kind==='heal' ? '#7affb7' : '#a1d8ff';
      ctx.beginPath(); ctx.arc(pk.x,pk.y,6,0,Math.PI*2); ctx.fill();
    });

    // player
    const p=game.p;
    ctx.fillStyle = (p.ifr>0||p.wAct)?'#ffd6d9':p.color;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
    if (p.wAct){ ctx.strokeStyle='#9adfff'; ctx.globalAlpha=0.6; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(p.x,p.y,150,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }

    // shots
    pshots.forEach(s=>{ ctx.fillStyle=s.color; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); });

    // floating texts
    floatTexts.forEach(ft=>{ ft.t+=16; ft.y+=ft.vy; ctx.fillStyle=ft.color; ctx.globalAlpha=1 - ft.t/ft.life; ctx.font='12px system-ui'; ctx.textAlign='center'; ctx.fillText(ft.text, ft.x, ft.y); ctx.globalAlpha=1; });
    for (let i=floatTexts.length-1;i>=0;i--) if ((floatTexts[i].t||0)>=(floatTexts[i].life||1100)) floatTexts.splice(i,1);

    // overlays
    ctx.fillStyle='#a9b'; ctx.textAlign='center';
    if (paused){ ctx.font='bold 26px system-ui'; ctx.fillText('Paused', canvas.width/2, 56); }
    else if (!p.alive){ ctx.font='bold 26px system-ui'; ctx.fillText('You fell. Restarting…', canvas.width/2, 56); }

    ctx.restore();
  }

  // ================= INPUT/UPGRADES/INFO =================
  window.addEventListener('keydown', e=>{
    keys.add(e.code);
    if (e.code==='KeyP'){ paused=!paused; if(!paused) lockUntil=performance.now()+CFG.wind.lock; e.preventDefault(); }
    if (e.code==='KeyR'){ hardReset(); e.preventDefault(); }
    if (e.code==='Space'){ e.preventDefault(); }
  });
  window.addEventListener('keyup', e=>{ keys.delete(e.code); });
  const isDown=code=>keys.has(code);
  const wasPressed=code=>keys.has(code);

  const UPGRADES = [
    { id:'hp', label:'+ Max HP (+12)', apply:()=>save.upg.hp++ },
    { id:'speed', label:'+ Move Speed', apply:()=>save.upg.speed++ },
    { id:'windMax', label:'+ Wind cap (+25)', apply:()=>save.upg.windMax++ },
    { id:'windPow', label:'+ Wind power', apply:()=>save.upg.windPow++ },
    { id:'dash', label:'- Dash cooldown', apply:()=>save.upg.dash++ },
    { id:'fire', label:'+ Shot Damage/Speed', apply:()=>save.upg.fire++ }
  ];
  function showUpgrade(){
    upGrid.innerHTML='';
    shuffle(UPGRADES).slice(0,3).forEach(u=>{
      const c=document.createElement('div'); c.className='card';
      c.innerHTML = `<div>${u.label}</div><div style="opacity:.8">Current: ${save.upg[u.id]||0}</div>`;
      c.onclick=()=>{ u.apply(); persist(); upDlg.close(); };
      upGrid.appendChild(c);
    });
    skipUpg.onclick=()=> upDlg.close();
    upDlg.showModal();
  }
  function shuffle(a){ return a.map(x=>[Math.random(),x]).sort((A,B)=>A[0]-B[0]).map(x=>x[1]); }

  function info(text, key){
    infoBody.textContent = text;
    infoOk.onclick=()=>{ save.info[key]=true; persist(); infoDlg.close(); };
    infoDlg.showModal();
  }

  // ================= WIND =================
  function addWind(dt){
    const p=game.p; if (performance.now()<lockUntil) return;
    p.tpTick += dt; if (p.tpTick>=1000){ p.tpAcc=0; p.tpTick=0; }
    const left = Math.max(0, CFG.wind.capPS - p.tpAcc);
    const add = Math.min(left, CFG.wind.graze*(dt/16));
    p.tpAcc += add; p.wind = clamp(p.wind + add, 0, windMax());
  }

  // ================= LOOP START =================
  function loop(){
    const now=performance.now(); const dt = Math.min(40, now - last); last=now;
    if (!game) startRun();
    step(dt);
    draw();
    requestAnimationFrame(loop);
  }

  pauseBtn.onclick = ()=>{ paused=!paused; if(!paused) lockUntil=performance.now()+CFG.wind.lock; };
  resetBtn.onclick = ()=> hardReset();

  startRun();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>

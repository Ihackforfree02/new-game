<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Bullet Heart Duel — 50 Level Run (TP Burst)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<style>
  html,body { margin:0; background:#0b0b0f; color:#e7e7ef; font:14px/1.5 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
  #wrap { display:flex; flex-direction:column; align-items:center; gap:8px; padding:10px; }
  canvas { background:#000; border:2px solid #e7e7ef; image-rendering: pixelated; touch-action:none; }
  .hud { width: 920px; max-width: 96vw; display:flex; justify-content:space-between; align-items:center; }
  .small { font-size:12px; opacity:.8; }
  .bar { height:10px; background:#26263b; border:1px solid #3a3a5d; position:relative; width:240px; }
  .fill { height:100%; background:#7affb7; }
  .bar.blue .fill { background:#6cb6ff; }
  .pill { padding:4px 8px; border-radius:999px; border:1px solid #3a3a5d; }
  button { background:#191924; color:#e7e7ef; border:1px solid #3a3a5d; padding:6px 10px; cursor:pointer; }
  button:hover { background:#20203a; }
</style>
</head>
<body>
<div id="wrap">
  <div class="hud" id="hudTop">
    <span id="status">Move: WASD/Arrows • Burst: E • Shoot: Space (Boss Attack) • P: Pause • M: Mute • K: Skin</span>
    <div style="display:flex; gap:8px;">
      <button id="pauseBtn">Pause</button>
      <button id="muteBtn">Mute</button>
      <button id="resetBtn">Reset run</button>
    </div>
  </div>

  <canvas id="game" width="920" height="660"></canvas>

  <div class="hud" id="hudBottom">
    <div style="display:flex; gap:16px; align-items:center;">
      <span>HP</span>
      <div class="bar"><div id="hpFill" class="fill" style="width:100%;"></div></div>
      <span id="hpText"></span>
    </div>
    <div style="display:flex; gap:16px; align-items:center;">
      <span>TP</span>
      <div class="bar blue"><div id="burstFill" class="fill" style="width:0%;"></div></div>
      <span id="burstText"></span>
    </div>
    <div style="display:flex; gap:16px; align-items:center;">
      <span class="pill" id="lvText"></span>
      <span class="pill" id="phaseText"></span>
      <span class="pill" id="timerText"></span>
      <span class="pill" id="scoreText"></span>
      <span class="pill" id="skinText"></span>
    </div>
  </div>

  <div class="small">50-level run. 20s survive levels. TP charges by grazing and proximity. Anti-pause-abuse enabled.</div>
</div>

<script>
(() => {
  'use strict';

  // ======================= CONFIG =======================
  const CONFIG = {
    arena: { x: 160, y: 120, w: 600, h: 440, border: 3, color: '#c9c9ff' },
    player: {
      r: 7, speed: 3.1, boost: 1.25,
      iframes: 800, maxHP: 92,
      grazeRadius: 18, grazeScore: 3, dmgShake: 5
    },
    // Survive phases last 20s now (boss and regular). Attack window unchanged.
    cycle: { surviveSec: 20, attackSec: 10 },
    sfx: { enabled: true, vol: 0.18 },
    bullets: { playerSpeed: 6.7, playerCooldown: 130, playerDmg: 10 },
    // TP-like Burst: slower base, most gain from graze + proximity; anti-pause lockout.
    burst: {
      max: 100,
      gainPerGraze: 0.45,      // base per close graze (slow)
      proxRadius: 90,          // distance for proximity TP trickle
      proxPerSec: 0.18,        // small per-second near-danger gain
      passivePerSec: 0.04,     // tiny passive trickle
      perSecondCap: 12,        // max TP per second (avoid spikes)
      damage: 120,
      clearBullets: true,
      cooldown: 3000,
      antiPauseLockMs: 900     // TP gain/use blocked after unpausing
    },
    visual: {
      bg:'#000', trail:true, trailAlpha:0.07,
      warn:'#ffd166', beam:'#73c0ff',
      bone:'#e5e5ff', knife:'#ffaa99', orb:'#a1ffea',
      fall:'#ffcc88', hammer:'#ff9d6c', fire:'#ff6b3d'
    },
    MAX_LEVEL: 50,
    saveKey: 'bhd_run_v4_50_tp'
  };

  const SKINS = [
    { id:'classic',  name:'Classic',  color:'#ff4d6d', trail:'#ffb3c1' },
    { id:'ember',    name:'Ember',    color:'#ff9a63', trail:'#ffd0b7' },
    { id:'sapphire', name:'Sapphire', color:'#59b0ff', trail:'#b7daff' },
    { id:'emerald',  name:'Emerald',  color:'#53ffa3', trail:'#b9ffd6' },
    { id:'void',     name:'Void',     color:'#d5ccff', trail:'#a18aff' },
    { id:'carbon',   name:'Carbon',   color:'#b3b3b3', trail:'#e0e0e0' }
  ];

  // ======================= DOM =======================
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const hpFill = document.getElementById('hpFill');
  const hpText = document.getElementById('hpText');
  const burstFill = document.getElementById('burstFill');
  const burstText = document.getElementById('burstText');
  const lvText = document.getElementById('lvText');
  const phaseText = document.getElementById('phaseText');
  const timerText = document.getElementById('timerText');
  const scoreText = document.getElementById('scoreText');
  const skinText = document.getElementById('skinText');

  document.getElementById('pauseBtn').onclick = togglePause;
  document.getElementById('muteBtn').onclick = ()=> { CONFIG.sfx.enabled = !CONFIG.sfx.enabled; persist(); };
  document.getElementById('resetBtn').onclick = hardReset;

  // ======================= SAVE =======================
  function loadSave(){
    try{
      const raw = localStorage.getItem(CONFIG.saveKey);
      if (!raw) return { level:1, hp:CONFIG.player.maxHP, best:0, skin:'classic', unlocked:['classic'], muted:false, completed:false };
      const s = JSON.parse(raw);
      if (s.muted) CONFIG.sfx.enabled = false;
      s.level = clamp(s.level|0, 1, CONFIG.MAX_LEVEL);
      s.hp = clamp(s.hp|0, 1, CONFIG.player.maxHP);
      s.unlocked = Array.isArray(s.unlocked) && s.unlocked.length ? s.unlocked : ['classic'];
      s.skin = s.unlocked.includes(s.skin) ? s.skin : s.unlocked[0];
      s.best = s.best|0;
      s.completed = !!s.completed;
      return s;
    } catch(e){
      return { level:1, hp:CONFIG.player.maxHP, best:0, skin:'classic', unlocked:['classic'], muted:false, completed:false };
    }
  }
  function persist(){
    try{
      localStorage.setItem(CONFIG.saveKey, JSON.stringify({
        level: save.level,
        hp: Math.max(0, Math.ceil(game?.player?.hp ?? save.hp)),
        best: save.best|0,
        skin: save.skin,
        unlocked: Array.from(new Set(save.unlocked)),
        muted: !CONFIG.sfx.enabled,
        completed: !!save.completed
      }));
    }catch(e){}
  }
  function hardReset(){
    save = { level:1, hp:CONFIG.player.maxHP, best:0, skin:'classic', unlocked:['classic'], muted:!CONFIG.sfx.enabled, completed:false };
    persist();
    startRun();
  }
  let save = loadSave();

  // ======================= AUDIO =======================
  let audioCtx;
  function tone(freq, dur=0.06, type='square', vol=CONFIG.sfx.vol){
    if (!CONFIG.sfx.enabled) return;
    try{
      audioCtx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
      const o = audioCtx.createOscillator(), g = audioCtx.createGain();
      o.type=type; o.frequency.value=freq;
      g.gain.value=0; g.gain.linearRampToValueAtTime(vol, audioCtx.currentTime+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+dur);
      o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+dur+0.02);
    }catch(e){}
  }

  // ======================= UTIL =======================
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a + Math.random()*(b-a);
  const dist2=(x1,y1,x2,y2)=>{const dx=x2-x1,dy=y2-y1;return dx*dx+dy*dy;};
  const circleRectHit=(cx,cy,r, rx,ry,rw,rh)=>{const nx=clamp(cx,rx,rx+rw),ny=clamp(cy,ry,ry+rh);const dx=cx-nx,dy=cy-ny;return dx*dx+dy*dy<=r*r;};

  // ======================= ENTITIES =======================
  const bullets=[]; const hazards=[]; const telegraphs=[]; const pshots=[]; const floatTexts=[];
  function clearWave(){ bullets.length=0; hazards.length=0; telegraphs.length=0; pshots.length=0; floatTexts.length=0; }
  function popup(x,y,text,color='#a6c8ff'){ floatTexts.push({x,y,vy:-0.4,t:0,life:1000,text,color}); }

  // enemy spawners
  function spawnOrb(x,y,vx,vy,r=6,dmg=7){ bullets.push({kind:'orb',x,y,vx,vy,r,dmg,color:CONFIG.visual.orb}); }
  function spawnBone(x,y,w,h,vx,vy,dmg=8){ bullets.push({kind:'rect',x,y,w,h,vx,vy,dmg,color:CONFIG.visual.bone}); }
  function spawnKnife(x,y,ang,spd,dmg=10){ bullets.push({kind:'knife',x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,w:6,h:16,angle:ang,spin:0.18,dmg,color:CONFIG.visual.knife}); }
  function spawnBeam(x,y,w,h,delay=500,hold=600,dmg=12){
    telegraphs.push({kind:'beamWarn',x,y,w,h,t:0,delay}); hazards.push({kind:'beam',x,y,w,h,active:false,t:0,hold,dmg,color:CONFIG.visual.beam});
  }
  function spawnHammerColumn(x,delay=700,hold=500,dmg=14){
    telegraphs.push({kind:'hammerWarnCol',x,delay,t:0}); hazards.push({kind:'hammerCol',x,active:false,t:0,w:70,hold,dmg,color:CONFIG.visual.hammer});
  }
  function spawnHammerArc(cx,cy,radius,span,delay=700,hold=450,dmg=14){
    telegraphs.push({kind:'hammerWarnArc',cx,cy,radius,span,delay,t:0}); hazards.push({kind:'hammerArc',cx,cy,radius,span,active:false,t:0,hold,dmg,color:CONFIG.visual.hammer});
  }
  function spawnFireJetVertical(x, delay=600, hold=900, dmg=10){
    telegraphs.push({kind:'fireWarnCol',x,delay,t:0}); hazards.push({kind:'fireCol',x,active:false,t:0,w:40,hold,dmg,color:CONFIG.visual.fire});
  }
  function spawnFireBall(x,y,ang,spd=2.3,r=7,dmg=9){
    bullets.push({kind:'fire',x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,r,dmg,color:CONFIG.visual.fire, flicker:0});
  }

  // player shots
  function spawnPShot(x,y,dx,dy){
    const sp = CONFIG.bullets.playerSpeed; const n = Math.hypot(dx,dy)||1;
    pshots.push({x,y,vx:dx/n*sp,vy:dy/n*sp,r:3,color:'#c0ff7a',dmg:CONFIG.bullets.playerDmg});
  }

  // ======================= DIFFICULTY SCALING =======================
  function decade(level){ return Math.ceil(level/10); }
  function isBossLevel(level){ return level % 10 === 0; }
  function levelScale(level){
    const dec = decade(level);
    const intra = (level - (dec-1)*10);
    const perLevel = 1 + 0.05*(intra-1);
    const perDecade = 1 + 0.18*(dec-1);
    return perLevel * perDecade;
  }

  // ======================= PATTERNS =======================
  const Patterns = {
    corridorBeams: (t,dt,a,ls)=>{
      t.acc=(t.acc||0)+dt;
      const rate = 1100/ls;
      if (t.acc>rate){
        t.acc=0;
        const rows = 2 + Math.floor(ls%3);
        for (let i=0;i<rows;i++){
          if (Math.random()<0.5){
            const y = Math.floor(rand(a.y+50,a.y+a.h-50));
            spawnBeam(a.x,y,a.w,8, Math.max(300, 520 - 30*ls), Math.max(420, 640 - 10*ls), 8+Math.floor(ls));
          } else {
            const x = Math.floor(rand(a.x+50,a.x+a.w-50));
            spawnBeam(x,a.y,8,a.h, Math.max(300, 520 - 30*ls), Math.max(420, 640 - 10*ls), 8+Math.floor(ls));
          }
        }
        tone(300,0.04,'sine');
      }
    },
    crossBones: (t,dt,a,ls)=>{
      t.acc=(t.acc||0)+dt;
      const rate = Math.max(120, 260 - 8*ls);
      if (t.acc > rate){
        t.acc=0;
        const s = 1.9 + 0.18*ls;
        const y = Math.floor(rand(a.y+20,a.y+a.h-20));
        spawnBone(a.x-24,y,22,10, s,0,8+Math.floor(ls/2));
        spawnBone(a.x+a.w+4,y,22,10, -s,0,8+Math.floor(ls/2));
        const x = Math.floor(rand(a.x+20,a.x+a.w-20));
        spawnBone(x,a.y-24,10,22, 0,s,8+Math.floor(ls/2));
        spawnBone(x,a.y+a.h+4,10,22, 0,-s,8+Math.floor(ls/2));
        tone(420,0.03);
      }
    },
    chaseOrbs: (t,dt,a,ls,player)=>{
      t.acc=(t.acc||0)+dt;
      const rate = Math.max(220, 520 - 14*ls);
      if (t.acc>rate){
        t.acc=0;
        const edges = [
          {x: rand(a.x, a.x+a.w), y: a.y-10},
          {x: rand(a.x, a.x+a.w), y: a.y+a.h+10},
          {x: a.x-10, y: rand(a.y, a.y+a.h)},
          {x: a.x+a.w+10, y: rand(a.y, a.y+a.h)}
        ];
        for (let k=0;k<2+Math.floor(ls/3);k++){
          const e = edges[Math.floor(rand(0,4))];
          const ang = Math.atan2(player.y - e.y, player.x - e.x);
          spawnOrb(e.x,e.y, Math.cos(ang)*(1.6+0.12*ls), Math.sin(ang)*(1.6+0.12*ls), 7, 7+Math.floor(ls/2));
        }
      }
      bullets.forEach(b=>{
        if (b.kind==='orb'){
          const ang = Math.atan2(game.player.y - b.y, game.player.x - b.x);
          b.vx = b.vx*0.97 + Math.cos(ang)*0.05*(1+0.02*ls);
          b.vy = b.vy*0.97 + Math.sin(ang)*0.05*(1+0.02*ls);
        }
      });
    },
    hammerAndFire: (t,dt,a,ls,player)=>{
      t.acc=(t.acc||0)+dt; t.fire=(t.fire||0)+dt;
      const colDelay = Math.max(280, 560 - 18*ls);
      const arcDelay = Math.max(300, 540 - 16*ls);
      const fireDelay = Math.max(180, 360 - 10*ls);

      if (t.acc>Math.min(1400, 1400/Math.sqrt(ls))){
        t.acc=0;
        const cols = 2 + Math.floor(ls/2);
        for (let i=0;i<cols;i++){
          const x = Math.floor(rand(a.x+60, a.x+a.w-60));
          spawnHammerColumn(x, colDelay, Math.max(420, 520+25*ls), 10+Math.floor(ls));
        }
        const cx = a.x + a.w/2, cy = a.y + a.h/2;
        const span = Math.min(Math.PI/1.6, Math.PI/3 + ls*0.10);
        const ang = Math.atan2(player.y-cy, player.x-cx);
        spawnHammerArc(cx,cy, 150+ls*14, {a:ang-span/2, b:ang+span/2}, arcDelay, Math.max(380, 480+20*ls), 10+Math.floor(ls));
        tone(200,0.06,'triangle');
      }
      if (t.fire>fireDelay){
        t.fire=0;
        const jets = 1 + Math.floor(ls/3);
        for (let i=0;i<jets;i++){
          const x = Math.floor(rand(a.x+50, a.x+a.w-50));
          spawnFireJetVertical(x, Math.max(220, 420-10*ls), Math.max(600, 800), 8+Math.floor(ls));
        }
        const balls = 3 + Math.floor(ls/2);
        for (let i=0;i<balls;i++){
          const pos = [
            {x: rand(a.x,a.x+a.w), y: a.y-10},
            {x: rand(a.x,a.x+a.w), y: a.y+a.h+10},
            {x: a.x-10, y: rand(a.y,a.y+a.h)},
            {x: a.x+a.w+10, y: rand(a.y,a.y+a.h)}
          ][Math.floor(rand(0,4))];
          const ang = Math.atan2(player.y-pos.y, player.x-pos.x) + rand(-0.22,0.22);
          spawnFireBall(pos.x,pos.y, ang, 2.0+0.10*ls, 7, 9+Math.floor(ls));
        }
        tone(360,0.05,'sawtooth');
      }
    }
  };

  // ======================= BOSSES (5 unique) =======================
  const Bosses = [
    { name:'Hammer Saint',     color:'#ffd2ae', hp: 1200, style:1 },
    { name:'Forge Warden',     color:'#ffb38f', hp: 1500, style:2 },
    { name:'Anvil Sovereign',  color:'#ffcaa1', hp: 1800, style:3 },
    { name:'Pyre Regent',      color:'#ff9f7a', hp: 2100, style:4 },
    { name:'Caldera Monarch',  color:'#ffa86b', hp: 2500, style:5 }
  ];
  function pickBoss(level){
    const idx = Math.min(4, Math.floor(level/10)-1);
    return Bosses[idx];
  }

  // ======================= GAME STATE =======================
  let game, paused=false, pauseLockUntil=0, lastT=performance.now(), shake=0, score=0;

  function makePlayer(){
    const skin = SKINS.find(s=>s.id===save.skin) || SKINS[0];
    return {
      x: CONFIG.arena.x + CONFIG.arena.w/2,
      y: CONFIG.arena.y + CONFIG.arena.h/2,
      r: CONFIG.player.r,
      baseColor: skin.color, trail: skin.trail,
      hp: clamp(save.hp, 1, CONFIG.player.maxHP),
      iframes: 0, alive: true,
      burst: 0, burstCD: 0, shootCD: 0,
      tpAcc: 0 // per-second cap accumulator
    };
  }
  function makeBoss(def, level){
    const ls = levelScale(level);
    const scaleHP = 1 + 0.15*(decade(level)-1);
    return { name:def.name, color:def.color, hp: Math.ceil(def.hp*scaleHP), maxHP: Math.ceil(def.hp*scaleHP), style:def.style, time:0 };
  }

  function startRun(){
    if (save.completed && save.level>=CONFIG.MAX_LEVEL){
      save.level = CONFIG.MAX_LEVEL;
    }
    game = {
      player: makePlayer(),
      arena: { ...CONFIG.arena },
      level: save.level|0,
      state: isBossLevel(save.level) ? 'bossSurvive' : 'survive',
      timer: CONFIG.cycle.surviveSec * 1000,
      boss: isBossLevel(save.level) ? makeBoss(pickBoss(save.level), save.level) : null,
      won: false, deathTime:0, t:0
    };
    score = Math.max(score|0, save.best|0);
    clearWave();
    updateUI();
  }

  // ======================= DAMAGE/HEAL =======================
  function damagePlayer(amount){
    const p=game.player; if (!p.alive) return;
    if (p.iframes>0) return;
    p.hp -= amount; p.iframes = CONFIG.player.iframes;
    shake = Math.max(shake, CONFIG.player.dmgShake);
    tone(120,0.08,'sawtooth');
    if (p.hp<=0){ p.alive=false; p.hp=0; game.deathTime=game.t; }
    save.hp = Math.max(0, Math.ceil(p.hp)); persist(); updateUI();
  }
  function damageBoss(amount){
    if (!game.boss) return;
    game.boss.hp = Math.max(0, game.boss.hp - amount);
    if (game.boss.hp<=0 && !game.won){ onBossDefeated(); }
  }
  function onBossDefeated(){
    game.won = true;
    score += 2500;
    tone(660,0.25,'triangle'); tone(880,0.25,'sine');
    const locked = SKINS.map(s=>s.id).filter(id=>!save.unlocked.includes(id));
    if (locked.length){
      const award = locked[Math.floor(Math.random()*locked.length)];
      save.unlocked.push(award);
      popup(canvas.width/2, 90, 'New Skin Unlocked!');
      popup(canvas.width/2, 110, SKINS.find(s=>s.id===award).name);
    }
    setTimeout(()=> advanceLevel(), 900);
  }
  function advanceLevel(){
    if (save.level >= CONFIG.MAX_LEVEL){
      save.completed = true;
      save.best = Math.max(save.best|0, Math.floor(score));
      persist();
      popup(canvas.width/2, 70, 'Run Complete!');
      setTimeout(()=>{ startRun(); }, 1200);
      return;
    }
    save.level = clamp((save.level|0)+1, 1, CONFIG.MAX_LEVEL);
    save.best = Math.max(save.best|0, Math.floor(score));
    persist();
    startRun();
  }

  // ======================= PAUSE =======================
  function togglePause(){
    paused = !paused;
    if (!paused){
      // Anti-pause-abuse: block TP gain and Burst usage briefly after unpausing
      pauseLockUntil = performance.now() + CONFIG.burst.antiPauseLockMs;
    }
  }

  // ======================= LOOP =======================
  const patternState = {};
  function step(dt){
    if (!game) return;
    if (paused) return; // full freeze

    game.t += dt;

    const a = game.arena, p = game.player, lvl = game.level;
    const ls = levelScale(lvl);
    const now = performance.now();
    const antiPauseActive = now < pauseLockUntil;

    // input/move (WASD + Arrows)
    let sp = CONFIG.player.speed * (keys.ShiftLeft||keys.ShiftRight ? 1 : CONFIG.player.boost);
    let vx = (keys.ArrowRight||keys.KeyD?1:0) - (keys.ArrowLeft||keys.KeyA?1:0);
    let vy = (keys.ArrowDown||keys.KeyS?1:0) - (keys.ArrowUp||keys.KeyW?1:0);
    const len = Math.hypot(vx,vy)||1; vx/=len; vy/=len;
    p.x += vx*sp; p.y += vy*sp;
    p.x = clamp(p.x, a.x + p.r + 2, a.x + a.w - p.r - 2);
    p.y = clamp(p.y, a.y + p.r + 2, a.y + a.h - p.r - 2);
    if (p.iframes>0) p.iframes -= dt;

    // waves
    if (game.state==='survive'){
      Patterns.corridorBeams(patternState.cb = patternState.cb||{}, dt, a, ls);
      Patterns.crossBones(  patternState.xb = patternState.xb||{}, dt, a, ls);
      Patterns.chaseOrbs(   patternState.co = patternState.co||{}, dt, a, ls, p);
    } else if (game.state==='bossSurvive'){
      Patterns.hammerAndFire(patternState.hf = patternState.hf||{}, dt, a, Math.max(2, ls), p);
    } else if (game.state==='bossAttack'){
      p.shootCD -= dt;
      if ((keys.Space) && p.shootCD<=0){
        p.shootCD = CONFIG.bullets.playerCooldown/Math.min(1.4, Math.sqrt(ls));
        spawnPShot(p.x, p.y-2, 0, -1);
        tone(500,0.03,'triangle');
      }
    }

    // update bullets
    for (let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      b.x += b.vx; b.y += b.vy;
      if (b.kind==='knife') b.angle += b.spin;
      if (b.kind==='fire') b.flicker = 1 - Math.random()*0.4;
      if (b.x<-240 || b.x>canvas.width+240 || b.y<-240 || b.y>canvas.height+240){ bullets.splice(i,1); continue; }

      let hit=false;
      if (b.kind==='rect'){ if (circleRectHit(p.x,p.y,p.r, b.x,b.y,b.w,b.h)) hit=true; }
      else if (b.kind==='knife'){ if (circleRectHit(p.x,p.y,p.r, b.x-6,b.y-8,12,16)) hit=true; }
      else if (b.kind==='orb' || b.kind==='fire'){
        const rr=(b.r||6)+p.r; if (dist2(p.x,p.y,b.x,b.y) <= rr*rr) hit=true;
      }
      if (hit) damagePlayer(b.dmg||8);
    }

    // hazards
    for (let i=hazards.length-1;i>=0;i--){
      const h=hazards[i];
      h.t=(h.t||0)+dt;
      if (h.kind==='beam'){
        if (h.active){
          if (circleRectHit(p.x,p.y,p.r, h.x,h.y,h.w,h.h)) damagePlayer(h.dmg);
          if (h.t>h.hold) hazards.splice(i,1);
        }
      } else if (h.kind==='hammerCol'){
        if (h.active){
          const rx = h.x - h.w/2, ry = a.y, rw = h.w, rh = a.h;
          if (circleRectHit(p.x,p.y,p.r, rx,ry,rw,rh)) damagePlayer(h.dmg);
          if (h.t>h.hold) hazards.splice(i,1);
        }
      } else if (h.kind==='hammerArc'){
        if (h.active){
          const ang = Math.atan2(p.y-h.cy, p.x-h.cx);
          const norm=(x)=>{while(x<-Math.PI)x+=2*Math.PI; while(x>Math.PI)x-=2*Math.PI; return x;};
          const A=norm(h.span.a), B=norm(h.span.b), X=norm(ang);
          const mid=norm((A+B)/2), half=Math.abs(norm(B-A))/2 + 0.2;
          const inSpan = Math.abs(norm(X-mid))<=half;
          const r2 = dist2(p.x,p.y,h.cx,h.cy);
          if (inSpan && r2 <= (h.radius+22)*(h.radius+22) && r2 >= (h.radius-38)*(h.radius-38)) damagePlayer(h.dmg);
          if (h.t>h.hold) hazards.splice(i,1);
        }
      } else if (h.kind==='fireCol'){
        if (h.active){
          if (circleRectHit(p.x,p.y,p.r, h.x-20, a.y, 40, a.h)) damagePlayer(h.dmg);
          if (h.t>h.hold) hazards.splice(i,1);
        }
      }
    }

    // telegraphs activation
    for (let i=telegraphs.length-1;i>=0;i--){
      const tg=telegraphs[i]; tg.t=(tg.t||0)+dt;
      if (tg.kind==='beamWarn' && tg.t>=tg.delay){
        const b=hazards.find(h=>h.kind==='beam'&&h.x===tg.x&&h.y===tg.y&&h.w===tg.w&&h.h===tg.h&&!h.active);
        if (b){ b.active=true; b.t=0; tone(700,0.05,'square'); }
        telegraphs.splice(i,1);
      } else if (tg.kind==='hammerWarnCol' && tg.t>=tg.delay){
        const h=hazards.find(x=>x.kind==='hammerCol'&&x.x===tg.x&&!x.active);
        if (h){ h.active=true; h.t=0; tone(200,0.06,'square'); }
        telegraphs.splice(i,1);
      } else if (tg.kind==='hammerWarnArc' && tg.t>=tg.delay){
        const h=hazards.find(x=>x.kind==='hammerArc'&&x.cx===tg.cx&&x.cy===tg.cy&&!x.active);
        if (h){ h.active=true; h.t=0; tone(240,0.06,'square'); }
        telegraphs.splice(i,1);
      } else if (tg.kind==='fireWarnCol' && tg.t>=tg.delay){
        const h=hazards.find(x=>x.kind==='fireCol'&&x.x===tg.x&&!x.active);
        if (h){ h.active=true; h.t=0; tone(380,0.05,'triangle'); }
        telegraphs.splice(i,1);
      }
    }

    // player shots → boss core
    for (let i=pshots.length-1;i>=0;i--){
      const s=pshots[i];
      s.x += s.vx; s.y += s.vy;
      if (game.state==='bossAttack'){
        const cx = canvas.width/2, cy = 70, r = 36;
        if (dist2(s.x,s.y,cx,cy) <= (r+2)*(r+2)){
          damageBoss(s.dmg); popup(s.x, s.y, `-${s.dmg}`, '#ffd6a1');
          pshots.splice(i,1); continue;
        }
      }
      if (s.y<-20 || s.x<-20 || s.x>canvas.width+20) pshots.splice(i,1);
    }

    // TP-style Burst charge
    // Reset per-second cap accumulator every 1000ms
    p.tpAcc = (p.tpAcc || 0);
    if (!p.tpTickT) p.tpTickT = 0;
    p.tpTickT += dt;
    if (p.tpTickT >= 1000){ p.tpAcc = 0; p.tpTickT = 0; }

    if (!antiPauseActive){ // no TP gain while in anti-pause lock
      let tpGain = 0;

      // Grazing: near-miss increments (primary source)
      for (let b of bullets){
        if (b.kind==='orb' || b.kind==='fire'){
          const rr = CONFIG.player.grazeRadius + (b.r||6) + p.r;
          const d2 = dist2(p.x,p.y,b.x,b.y);
          if (d2 <= rr*rr){
            tpGain += CONFIG.burst.gainPerGraze * (dt/16);
          }
        }
      }

      // Proximity trickle: if any hazard/beam/hammer column nearby, add small TP
      let nearDanger = false;
      const proxR2 = CONFIG.burst.proxRadius * CONFIG.burst.proxRadius;
      for (let h of hazards){
        if (h.active){
          // sample center of hazard area
          let hx, hy;
          if (h.kind==='hammerCol' || h.kind==='fireCol' || h.kind==='beam'){
            hx = clamp(p.x, h.x - (h.w||40)/2, h.x + (h.w||40)/2);
            hy = game.arena.y + game.arena.h/2;
          } else if (h.kind==='hammerArc'){
            hx = h.cx; hy = h.cy;
          }
          if (hx!=null){
            const d2 = dist2(p.x,p.y,hx,hy);
            if (d2 <= proxR2){ nearDanger = true; break; }
          }
        }
      }
      if (nearDanger) tpGain += CONFIG.burst.proxPerSec * (dt/1000);

      // Passive slow trickle
      tpGain += CONFIG.burst.passivePerSec * (dt/1000);

      // Cap per-second gain
      const capLeft = Math.max(0, CONFIG.burst.perSecondCap - p.tpAcc);
      const applied = Math.min(capLeft, tpGain);
      p.tpAcc += applied;
      p.burst = clamp(p.burst + applied, 0, CONFIG.burst.max);
    }

    // Burst use
    if (p.burstCD>0) p.burstCD -= dt;
    if (!antiPauseActive && keys.KeyE && p.burst>=CONFIG.burst.max && p.burstCD<=0){
      p.burst=0; p.burstCD=CONFIG.burst.cooldown;
      bullets.length=0; hazards.length=0; telegraphs.length=0;
      if (game.boss) damageBoss(CONFIG.burst.damage);
      popup(p.x, p.y-20, 'TP BURST!');
      tone(280,0.08,'sawtooth'); tone(560,0.12,'square'); tone(840,0.14,'triangle');
    }

    // timers & state transitions
    game.timer -= dt;
    if (game.state==='survive'){
      if (game.timer<=0){ advanceLevel(); }
    } else if (game.state==='bossSurvive'){
      if (game.timer<=0){
        game.state='bossAttack';
        game.timer = CONFIG.cycle.attackSec*1000;
        clearWave();
      }
    } else if (game.state==='bossAttack'){
      if (game.timer<=0){
        if (!game.won){
          game.state='bossSurvive';
          game.timer = CONFIG.cycle.surviveSec*1000;
          clearWave();
        }
      }
    }

    // score
    score += (game.state==='bossAttack'?10:6) * (dt/1000) * (1 + 0.15*(decade(lvl)-1));
    save.best = Math.max(save.best|0, Math.floor(score));

    // death
    if (!p.alive && game.t - game.deathTime > 1200){
      save.hp = CONFIG.player.maxHP; persist(); startRun();
    }

    updateUI();
  }

  // ======================= DRAW =======================
  function updateUI(){
    const p=game.player;
    const hpPct = Math.max(0,p.hp)/CONFIG.player.maxHP*100;
    hpFill.style.width = hpPct.toFixed(1)+'%';
    hpText.textContent = `${Math.max(0,Math.ceil(p.hp))}/${CONFIG.player.maxHP}`;
    const bPct = clamp(p.burst/CONFIG.burst.max,0,1)*100;
    burstFill.style.width = bPct.toFixed(1)+'%';
    burstText.textContent = p.burst>=CONFIG.burst.max ? 'Ready (E)' : `${Math.floor(bPct)}%`;

    const bossLabel = isBossLevel(game.level) ? ' (Boss)' : '';
    phaseText.textContent = game.state.replace('boss','Boss ').replace('survive','Survive').replace('Attack','Attack');
    lvText.textContent = `Level ${game.level}${bossLabel}`;
    timerText.textContent = `${Math.max(0,Math.ceil(game.timer/1000))}s`;
    scoreText.textContent = `Score ${Math.floor(score)}`;
    const skinName = (SKINS.find(s=>s.id===save.skin)||SKINS[0]).name;
    skinText.textContent = `Skin: ${skinName} (K to change)`;
  }

  function draw(){
    if (CONFIG.visual.trail){ ctx.fillStyle='rgba(0,0,0,'+CONFIG.visual.trailAlpha+')'; ctx.fillRect(0,0,canvas.width,canvas.height); }
    else { ctx.fillStyle=CONFIG.visual.bg; ctx.fillRect(0,0,canvas.width,canvas.height); }

    if (shake>0) shake -= 0.4;
    ctx.save(); ctx.translate(rand(-shake,shake), rand(-shake,shake));

    // arena
    const a = game.arena;
    ctx.strokeStyle=CONFIG.arena.color; ctx.lineWidth=CONFIG.arena.border; ctx.strokeRect(a.x,a.y,a.w,a.h);

    // boss core
    if (isBossLevel(game.level)){
      const cx=canvas.width/2, cy=70, r=36;
      ctx.fillStyle = game.boss?.color || '#bbb'; ctx.globalAlpha=0.5;
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
      ctx.fillStyle='#cfe'; ctx.font='12px system-ui'; ctx.textAlign='center';
      ctx.fillText(game.boss?.name || 'Boss', cx, cy+2);
      ctx.fillText(`${Math.ceil(game.boss?.hp||0)}/${game.boss?.maxHP||0}`, cx, cy+18);
    }

    // telegraphs
    telegraphs.forEach(tg=>{
      if (tg.kind==='beamWarn'){
        ctx.fillStyle=CONFIG.visual.warn; ctx.globalAlpha=0.25 + 0.25*Math.sin((tg.t||0)/70); ctx.fillRect(tg.x,tg.y,tg.w,tg.h); ctx.globalAlpha=1;
      } else if (tg.kind==='hammerWarnCol'){
        ctx.fillStyle=CONFIG.visual.hammer; ctx.globalAlpha=0.22; ctx.fillRect(tg.x-35, a.y, 70, a.h); ctx.globalAlpha=1;
      } else if (tg.kind==='hammerWarnArc'){
        ctx.strokeStyle=CONFIG.visual.hammer; ctx.globalAlpha=0.8; ctx.lineWidth=6; ctx.beginPath(); ctx.arc(tg.cx,tg.cy,tg.radius, tg.span.a, tg.span.b); ctx.stroke(); ctx.globalAlpha=1;
      } else if (tg.kind==='fireWarnCol'){
        ctx.fillStyle=CONFIG.visual.fire; ctx.globalAlpha=0.18; ctx.fillRect(tg.x-20, a.y, 40, a.h); ctx.globalAlpha=1;
      }
    });

    // hazards
    hazards.forEach(h=>{
      if (h.kind==='beam'){ ctx.fillStyle=h.active?CONFIG.visual.beam:CONFIG.visual.warn; ctx.globalAlpha=h.active?0.6:0.25; ctx.fillRect(h.x,h.y,h.w,h.h); ctx.globalAlpha=1; }
      else if (h.kind==='hammerCol'){ if (h.active){ ctx.fillStyle=h.color; ctx.globalAlpha=0.7; ctx.fillRect(h.x-35, a.y, 70, a.h); ctx.globalAlpha=1; } }
      else if (h.kind==='hammerArc'){ if (h.active){ ctx.strokeStyle=h.color; ctx.lineWidth=10; ctx.globalAlpha=0.8; ctx.beginPath(); ctx.arc(h.cx,h.cy,h.radius,h.span.a,h.span.b); ctx.stroke(); ctx.globalAlpha=1; } }
      else if (h.kind==='fireCol'){ if (h.active){ ctx.fillStyle=h.color; ctx.globalAlpha=0.45; ctx.fillRect(h.x-20,a.y,40,a.h); ctx.globalAlpha=1; } }
    });

    // bullets
    bullets.forEach(b=>{
      if (b.kind==='rect'){ ctx.fillStyle=b.color; ctx.fillRect(b.x,b.y,b.w,b.h); }
      else if (b.kind==='knife'){ ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.angle); ctx.fillStyle=b.color; ctx.fillRect(-b.w/2,-b.h/2,b.w,b.h); ctx.restore(); }
      else if (b.kind==='orb'){ ctx.fillStyle=b.color; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
      else if (b.kind==='fire'){ ctx.fillStyle=b.color; ctx.globalAlpha=0.8*(b.flicker||1); ctx.beginPath(); ctx.arc(b.x,b.y,b.r+rand(-1,1),0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
    });

    // player shots
    pshots.forEach(s=>{ ctx.fillStyle=s.color; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); });

    // player + skin trail
    const p=game.player;
    const tint = p.iframes>0 ? '#ffd6d9' : (p.baseColor||'#ff4d6d');
    ctx.fillStyle=tint; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
    if (Math.random()<0.6){ ctx.fillStyle=(p.trail||'#ffb3c1'); ctx.globalAlpha=0.5; ctx.beginPath(); ctx.arc(p.x+rand(-3,3),p.y+rand(-3,3),2,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }

    // float texts
    floatTexts.forEach(ft=>{ ft.t+=16; ft.y+=ft.vy; ctx.fillStyle=ft.color; ctx.globalAlpha=1 - ft.t/ft.life; ctx.font='12px system-ui'; ctx.textAlign='center'; ctx.fillText(ft.text, ft.x, ft.y); ctx.globalAlpha=1; });
    for (let i=floatTexts.length-1;i>=0;i--){ if (floatTexts[i].t>=floatTexts[i].life) floatTexts.splice(i,1); }

    // overlays
    ctx.fillStyle='#a9b'; ctx.textAlign='center';
    if (paused){
      ctx.font='bold 26px system-ui'; ctx.fillText('Paused', canvas.width/2, 56);
      const left = Math.max(0, Math.ceil((pauseLockUntil - performance.now())/1000));
      if (left>0){ ctx.font='bold 16px system-ui'; ctx.fillText(`TP locked for ${left}s after unpause`, canvas.width/2, 84); }
    } else if (!p.alive){
      ctx.font='bold 26px system-ui'; ctx.fillText('You fell. Restarting level…', canvas.width/2, 56);
    } else if (game.won){
      ctx.font='bold 26px system-ui'; ctx.fillText('Boss Down! Advancing…', canvas.width/2, 56);
    }

    ctx.restore();
  }

  // ======================= INPUT =======================
  const keys={};
  window.addEventListener('keydown', e=>{
    keys[e.code]=true;
    if (e.code==='KeyP'){ togglePause(); e.preventDefault(); }
    if (e.code==='KeyM'){ CONFIG.sfx.enabled = !CONFIG.sfx.enabled; persist(); e.preventDefault(); }
    if (e.code==='KeyK'){ cycleSkin(); e.preventDefault(); }
    if (e.code==='Space'){ e.preventDefault(); }
  });
  window.addEventListener('keyup', e=>{ keys[e.code]=false; });

  function cycleSkin(){
    const unlocked = save.unlocked.map(id=>SKINS.findIndex(s=>s.id===id)).filter(i=>i>=0).sort((a,b)=>a-b);
    const curIndex = SKINS.findIndex(s=>s.id===save.skin);
    let pos = unlocked.indexOf(curIndex);
    pos = (pos+1) % unlocked.length;
    save.skin = SKINS[unlocked[pos]].id;
    if (game && game.player){
      const skin = SKINS.find(s=>s.id===save.skin) || SKINS[0];
      game.player.baseColor = skin.color; game.player.trail = skin.trail; // apply instantly
    }
    persist(); updateUI();
  }

  // ======================= MAIN LOOP =======================
  function loop(){
    const t = performance.now();
    const dt = clamp(t - lastT, 0, 40);
    lastT = t;
    if (!game) startRun();
    step(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // auto-start
  startRun();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>

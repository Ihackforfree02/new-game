<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>Undertale Gold — Duelist → Shade Lord</title>
<style>
:root{--fg:#ffd166;--hp:#ff6b6b;--emerald:#7affb7;--ui:#0b0b0b;--line:#262626;--white:#fff}
html,body{height:100%;margin:0;background:#000;color:var(--fg);font-family:ui-monospace,monospace;image-rendering:pixelated;overflow:hidden}
#stage{position:fixed;left:50%;top:50%;transform-origin:top left;will-change:transform}
#wrap{position:relative;width:960px;height:720px}
canvas{display:block;width:960px;height:720px;border:4px solid #0a0a0f;background:#070606}

/* HUD */
#bossHUD{position:absolute;left:20px;top:22px;display:flex;flex-direction:column;gap:6px;z-index:3}
#bossName{font-size:14px;letter-spacing:0.5px}
#bossHP{height:10px;width:380px;background:#141414;border:1px solid #383838;position:relative}
#bossHPFill{position:absolute;left:0;top:0;bottom:0;background:var(--hp);width:100%}
#bossHPVal{font-size:12px;margin-top:2px}
#playerHUD{position:absolute;right:20px;top:22px;display:flex;flex-direction:column;gap:6px;align-items:flex-end;z-index:3}
#playerNameLabel{font-size:14px;color:#9be7c0;letter-spacing:0.5px}
#pHP{height:10px;width:260px;background:#141414;border:1px solid #383838;position:relative}
#pHPFill{position:absolute;left:0;top:0;bottom:0;background:var(--emerald);width:100%}
#pHPVal{font-size:12px;margin-top:2px}

/* Arena */
#box{position:absolute;left:240px;top:420px;width:480px;height:180px;border:3px solid #fff;display:none;z-index:1}

/* Dialogue (bigger) */
#bubble{position:absolute;left:50%;bottom:148px;transform:translateX(-50%);max-width:905px;min-height:124px;display:block;z-index:4}
.bub{background:var(--ui);border:2px solid #fff;padding:16px 20px}
#bubbleText{white-space:pre-line;line-height:1.6;font-size:16px}

/* Bottom UI (entire bar hides during enemy turn) */
#uiBar{position:absolute;left:50%;bottom:8px;transform:translateX(-50%);width:920px;height:116px;background:var(--ui);border:2px solid var(--line);display:flex;align-items:center;justify-content:space-between;padding:0 18px;z-index:3;transition:opacity .18s ease, transform .18s ease}
#uiBar.hidden{opacity:0;pointer-events:none;transform:translate(-50%,6px)}
.uiMenu{display:flex;gap:36px}
.uiBtn{display:flex;align-items:center;gap:10px;cursor:pointer}
.uiKey{width:20px;height:20px;border:2px solid #fff;display:flex;align-items:center;justify-content:center;font-weight:700}
.uiLabel{font-size:20px;letter-spacing:1px}
#uiCenter{font-size:14px}

/* Optional: small tips line */
#tips{position:absolute;left:50%;top:84px;transform:translateX(-50%);font-size:12px;color:#c8c8c8;opacity:.8}
</style>
</head>
<body>
<div id="stage"><div id="wrap">
  <!-- HUD -->
  <div id="bossHUD">
    <div id="bossName">Golden Duelist</div>
    <div id="bossHP"><div id="bossHPFill"></div></div>
    <div id="bossHPVal">000/000</div>
  </div>
  <div id="playerHUD">
    <div id="playerNameLabel">Traveler</div>
    <div id="pHP"><div id="pHPFill"></div></div>
    <div id="pHPVal">50/50</div>
  </div>

  <!-- Canvas + Arena -->
  <canvas id="cv" width="960" height="720" aria-label="Battlefield"></canvas>
  <div id="box" aria-hidden="true"></div>

  <!-- Dialogue -->
  <div id="bubble"><div class="bub"><div id="bubbleText"></div></div></div>

  <!-- Bottom UI -->
  <div id="uiBar">
    <div class="uiMenu" id="uiMenu">
      <div class="uiBtn" data-act="FIGHT"><div class="uiKey">Z</div><div class="uiLabel">FIGHT</div></div>
      <div class="uiBtn" data-act="ACT"><div class="uiKey">A</div><div class="uiLabel">ACT</div></div>
      <div class="uiBtn" data-act="ITEM"><div class="uiKey">I</div><div class="uiLabel">ITEM</div></div>
      <div class="uiBtn" data-act="MERCY"><div class="uiKey">M</div><div class="uiLabel">MERCY</div></div>
    </div>
    <div id="uiCenter">Your turn.</div>
  </div>

  <div id="tips">Move: Arrow keys / WASD — Confirm: Z/Enter — Cancel: X/Backspace</div>
</div></div>

<script>
"use strict";

/* ===== Responsive: fill screen, preserve aspect ===== */
const stage=document.getElementById('stage');
function resizeStage(){
  const W=960,H=720;
  const sx=innerWidth/W, sy=innerHeight/H;
  const s=Math.min(sx,sy);
  stage.style.transform=`translate(-50%, -50%) scale(${s})`;
}
addEventListener('resize',resizeStage,{passive:true}); resizeStage();

/* ===== Elements ===== */
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
const boxEl=document.getElementById('box');
const bossNameEl=document.getElementById('bossName');
const bossHPFill=document.getElementById('bossHPFill'), bossHPVal=document.getElementById('bossHPVal');
const pHPFill=document.getElementById('pHPFill'), pHPVal=document.getElementById('pHPVal');
const bubble=document.getElementById('bubble'), bubbleText=document.getElementById('bubbleText');
const uiMenu=document.getElementById('uiMenu');
const uiBar=document.getElementById('uiBar');
const uiCenter=document.getElementById('uiCenter');

/* ===== State ===== */
const ARENA={x:240,y:420,w:480,h:180};
const HEART={x:ARENA.x+ARENA.w/2,y:ARENA.y+ARENA.h/2,r:4,sp:300,i:0,hp:50,hpMax:50,_px:0,_py:0,_pdt:1/60};
let time=0, paused=false, turn='player', showArena=false;
let attack=null, phaseT=0, attackIx=0;
let bullets=[], scene={flinch:0,shake:0}; let damagePopup=null; let slashes=[];
let bossIndex=0; // 0: Golden Duelist, 1: Shade Lord

/* ===== Boss data ===== */
const BOSSES=[
  {
    key:'duelist',
    name:'Golden Duelist',
    hpMax:320,
    intro:["A golden hall. A mantis descends.","It bows. The trial begins."],
    draw:drawMantis,
    attacks:()=>[
      phase(4, patSpearDash(4,6)),      // fast dashes (6 dmg)
      phase(4, patArcRing(4,5)),        // arc ring (5 dmg)
      phase(4, patPlungeLines(4,4)),    // plunges (4 dmg)
      phase(5, patSweepingBeads(5,3)),  // sweeping beads (3 dmg)
      phase(7, patPressureMix(7))       // mixed spiral/homing/dash (varied 5-7 dmg)
    ]
  },
  {
    key:'shade',
    name:'Shade Lord',
    hpMax:360,
    intro:["The lights dim. A cloak of dusk unfurls.","A whisper: 'Endure'."],
    draw:drawShadeLord,
    attacks:()=>[
      phase(4.5, patVoidSlash(4.5,7)),      // slow heavy slashes (7 dmg)
      phase(4,   patShadowHoming(4,6)),     // homing shades (6 dmg)
      phase(4.5, patColumnFalls(4.5,5)),    // falling columns (5 dmg)
      phase(5,   patOrbitals(5,4)),         // orbitals that shoot (4 dmg)
      phase(7,   patShadePressure(7))       // pressure mix (varied 5-8 dmg)
    ]
  }
];
let BOSS=null;

/* ===== Bars ===== */
function bossBar(){bossHPFill.style.width=(380*Math.max(0,BOSS.hp/BOSS.hpMax))+'px'; bossHPVal.textContent=`${BOSS.hp}/${BOSS.hpMax}`; bossNameEl.textContent=BOSS.name;}
function updatePlayerHP(){pHPFill.style.width=(260*Math.max(0,HEART.hp/HEART.hpMax))+'px';pHPVal.textContent=`${HEART.hp}/${HEART.hpMax}`;}
updatePlayerHP();

/* ===== Dialogue ===== */
let lastDialog='';
function showBubble(t){lastDialog=t; bubble.style.display='block'; bubbleText.textContent=t;}
function hideBubble(){bubble.style.display='none';}
function restoreBubble(){ if(lastDialog){ bubbleText.textContent=lastDialog; bubble.style.display='block'; } }

/* ===== Input ===== */
const down=new Set();
addEventListener('keydown',e=>{
  down.add(e.key);
  if((e.key==='z'||e.key==='Z'||e.key==='Enter') && turn==='player'){
    showBubble('You strike.');
    bossHit(24);
    setTimeout(()=>{
      turn='enemy';
      uiCenter.textContent='Enemy turn';
      uiBar.classList.add('hidden'); // hide entire bar during attacks
      hideBubble();
      startAttack();
    },220);
  }
  if((e.key==='x'||e.key==='X'||e.key==='Backspace') && turn==='player'){
    showBubble('You steady yourself.');
  }
});
addEventListener('keyup',e=>down.delete(e.key));
function key(k){return down.has(k)||down.has(k.toUpperCase());}

/* ===== Draw: Mantis (Golden Duelist) ===== */
function drawMantis(ctx,t,flinch=0){
  const x=480, y=260 + Math.sin(t*5.6)*2.8;
  ctx.save();
  // halo
  ctx.globalAlpha=0.2; ctx.fillStyle='#fff1b6'; ctx.beginPath(); ctx.arc(x,y,54+Math.sin(t*2.8)*2,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
  if(flinch>0){ctx.globalAlpha=0.65;ctx.fillStyle='#fffbe0';ctx.beginPath();ctx.arc(x,y,50,0,Math.PI*2);ctx.fill();ctx.globalAlpha=1;}
  // wings
  ctx.fillStyle='#b8902f';
  ctx.beginPath(); ctx.moveTo(x-18,y+2); ctx.quadraticCurveTo(x-52,y+18+Math.sin(t*2)*2, x-10,y+42); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(x+18,y+2); ctx.quadraticCurveTo(x+52,y+18+Math.cos(t*2)*2, x+10,y+42); ctx.closePath(); ctx.fill();
  // thorax/abdomen
  ctx.fillStyle='#e5bf4d'; ctx.fillRect(x-6,y-10,12,44);
  ctx.fillStyle='#d8b44a'; for(let i=0;i<4;i++){ ctx.fillRect(x-5,y+28+i*6,10,4); }
  // head + crest
  ctx.fillStyle='#e5bf4d'; ctx.beginPath(); ctx.moveTo(x,y-38); ctx.lineTo(x-12,y-14); ctx.lineTo(x+12,y-14); ctx.closePath(); ctx.fill();
  ctx.fillStyle='#ffd166'; ctx.fillRect(x-2,y-44,4,10);
  // mandibles
  ctx.fillStyle='#e5bf4d';
  ctx.beginPath(); ctx.moveTo(x-6,y-14); ctx.lineTo(x-11,y-6); ctx.lineTo(x-3,y-10); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(x+6,y-14); ctx.lineTo(x+11,y-6); ctx.lineTo(x+3,y-10); ctx.closePath(); ctx.fill();
  // eyes + antennae
  ctx.fillStyle='#0c0c12'; ctx.fillRect(x-8,y-26,5,5); ctx.fillRect(x+3,y-26,5,5);
  ctx.strokeStyle='#ffd166'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(x-3,y-32); ctx.quadraticCurveTo(x-20,y-46+Math.sin(t*5)*2, x-26,y-58); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+3,y-32); ctx.quadraticCurveTo(x+20,y-46+Math.cos(t*5)*2, x+26,y-58); ctx.stroke();
  // raptorial legs
  ctx.strokeStyle='#ffd166'; ctx.lineWidth=4;
  ctx.beginPath(); ctx.moveTo(x-6,y+2); ctx.lineTo(x-28,y+8+Math.sin(t*3)*8); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x-28,y+8+Math.sin(t*3)*8); ctx.lineTo(x-42,y-2+Math.sin(t*3)*6); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+6,y+2); ctx.lineTo(x+28,y+8+Math.cos(t*3)*8); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+28,y+8+Math.cos(t*3)*8); ctx.lineTo(x+42,y-2+Math.cos(t*3)*6); ctx.stroke();
  // hind legs
  ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(x-4,y+20); ctx.lineTo(x-18,y+36); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+4,y+20); ctx.lineTo(x+18,y+36); ctx.stroke();
  ctx.restore();
}

/* ===== Draw: Shade Lord ===== */
function drawShadeLord(ctx,t,flinch=0){
  const x=480, y=250 + Math.sin(t*3.4)*2;
  ctx.save();
  // shadow aura
  ctx.globalAlpha=0.22; ctx.fillStyle='#2e2b3d'; ctx.beginPath(); ctx.arc(x,y,58+Math.sin(t*2)*2,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
  // flinch
  if(flinch>0){ctx.globalAlpha=0.55;ctx.fillStyle='#ccb7ff'; ctx.beginPath(); ctx.arc(x,y,52,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;}
  // cloak
  ctx.fillStyle='#4a3d66'; ctx.beginPath();
  ctx.moveTo(x-36,y-8); ctx.quadraticCurveTo(x,y-26, x+36,y-8);
  ctx.lineTo(x+24,y+36); ctx.lineTo(x-24,y+36); ctx.closePath(); ctx.fill();
  // mask
  ctx.fillStyle='#d9d1f0'; ctx.beginPath(); ctx.arc(x,y-18,12,0,Math.PI*2); ctx.fill();
  // eyes
  ctx.fillStyle='#0a0812'; ctx.fillRect(x-8,y-22,5,5); ctx.fillRect(x+3,y-22,5,5);
  // tendrils
  ctx.strokeStyle='#8e7ac6'; ctx.lineWidth=3;
  for(let k=0;k<3;k++){
    ctx.beginPath();
    ctx.moveTo(x + (k-1)*8, y+8);
    ctx.quadraticCurveTo(x+(k-1)*10, y+24+Math.sin(t*2+k)*6, x+(k-1)*20, y+42);
    ctx.stroke();
  }
  ctx.restore();
}

/* ===== Heart ===== */
function drawHeart(ctx,x,y,color='#ffd166',scale=0.8){
  ctx.save();ctx.translate(x,y);ctx.scale(scale,scale);
  const m=[[0,1,1,0,0,1,1,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,1,1,0,0,0]];
  ctx.fillStyle=color;const s=3;
  for(let r=0;r<m.length;r++) for(let c=0;c<m[r].length;c++) if(m[r][c]) ctx.fillRect((c-4)*s,(r-3)*s,s,s);
  ctx.restore();
}

/* ===== Spawn helpers (per-bullet damage) ===== */
function spawn(b){b.t=0; bullets.push(b); return b;}
function spawnAimed(fromx,fromy,speed,dmg,color='#fff',radius=3){
  const dx=HEART.x-fromx, dy=HEART.y-fromy, L=Math.hypot(dx,dy)||1;
  const vx=(dx/L)*speed, vy=(dy/L)*speed;
  return spawn({x:fromx,y:fromy,vx,vy,r:radius,col:color,dmg});
}

/* ===== Duelist patterns ===== */
function patSpearDash(duration=4, dmg=6){
  let t=0, gap=0.12, g=0;
  return {enter(){t=0;g=0;}, update(dt){t+=dt;g+=dt;
    if(g>=gap){g=0;const left=Math.random()<0.5;const y=ARENA.y+12+Math.random()*(ARENA.h-24);
      const x=left?ARENA.x-24:ARENA.x+ARENA.w+24; const dir=left?1:-1;
      spawn({x,y,vx:dir*380,vy:0,r:4,col:'#ffd166',dmg});}
  }, done(){return t>=duration;}};
}
function patPlungeLines(duration=4, dmg=4){
  let t=0, gap=0.16, g=0;
  return {enter(){t=0;g=0;}, update(dt){t+=dt;g+=dt;
    if(g>=gap){g=0;const cols=6; const step=ARENA.w/(cols+1); const i=1+Math.floor(Math.random()*cols);
      const x=ARENA.x+i*step + (Math.random()*16-8);
      spawn({x,y:ARENA.y-18,vx:0,vy:310,r:4,col:'#ffb347',dmg});}
  }, done(){return t>=duration;}};
}
function patArcRing(duration=4, dmg=5){
  let t=0, rate=0.42, g=0;
  return {enter(){t=0;g=0;}, update(dt){t+=dt;g+=dt;
    if(g>=rate){g=0;const cx=ARENA.x+ARENA.w/2, cy=ARENA.y+ARENA.h/2;
      const angles=[-0.95,-0.55,0.55,0.95];
      for(const a of angles){spawn({x:cx,y:cy,vx:Math.cos(a)*250,vy:Math.sin(a)*250,r:3,col:'#a6c7ff',dmg});}}
  }, done(){return t>=duration;}};
}
function patSweepingBeads(duration=5, dmg=3){
  let t=0, a=Math.random()*Math.PI*2, dir=Math.random()<0.5?-1:1, emit=0.09, g=0;
  const pivot={x:ARENA.x+ARENA.w/2, y:ARENA.y+ARENA.h/2};
  return {enter(){t=0;g=0;}, update(dt){t+=dt;g+=dt; a+=dir*1.2*dt;
    if(g>=emit){g=0;const lx=pivot.x+Math.cos(a)*(ARENA.w/2-12), ly=pivot.y+Math.sin(a)*(ARENA.h/2-12);
      spawnAimed(lx,ly,240,dmg,'#ffe799',3);}
  }, done(){return t>=duration;}};
}
function patHomingLanterns(duration=4, dmg=7){
  let t=0, rate=0.6, g=0;
  return {enter(){t=0;g=0;}, update(dt){t+=dt;g+=dt;
    if(g>=rate){g=0;const x=ARENA.x+Math.random()*ARENA.w, y=ARENA.y-10;
      spawnAimed(x,y,230,dmg,'#fff3b8',4);}
  }, done(){return t>=duration;}};
}
function patPressureMix(duration=7){
  const A=patArcRing(duration,5), B=patSpearDash(duration,6), C=patHomingLanterns(duration,7);
  return {enter(){A.enter();B.enter();C.enter();}, update(dt){A.update(dt);B.update(dt);C.update(dt);}, done(){return false;}};
}

/* ===== Shade Lord patterns ===== */
function patVoidSlash(duration=4.5, dmg=7){
  // Big slow crescent waves from center
  let t=0, rate=0.55, g=0, phase=0;
  return {enter(){t=0;g=0;phase=0;}, update(dt){
    t+=dt; g+=dt;
    if(g>=rate){g=0;phase++;
      const cx=ARENA.x+ARENA.w/2, cy=ARENA.y+ARENA.h/2;
      const dir = (phase%2===0)?1:-1;
      for(let k=0;k<8;k++){
        const a = (k/8)*Math.PI*2 + (dir>0?0.3:-0.3);
        spawn({x:cx,y:cy,vx:Math.cos(a)*210,vy:Math.sin(a)*210,r:4,col:'#c7b5ff',dmg});
      }
    }
  }, done(){return t>=duration;}};
}
function patShadowHoming(duration=4, dmg=6){
  let t=0, rate=0.5, g=0;
  return {enter(){t=0;g=0;}, update(dt){
    t+=dt; g+=dt;
    if(g>=rate){g=0; const sides=[[ARENA.x-18, ARENA.y+Math.random()*ARENA.h],[ARENA.x+ARENA.w+18, ARENA.y+Math.random()*ARENA.h],[ARENA.x+Math.random()*ARENA.w, ARENA.y-18]];
      const [x,y]=sides[Math.floor(Math.random()*sides.length)];
      spawnAimed(x,y,220,dmg,'#b49aed',4);
    }
  }, done(){return t>=duration;}};
}
function patColumnFalls(duration=4.5, dmg=5){
  // Thicker falling columns that create lingering orbs
  let t=0, rate=0.38, g=0;
  return {enter(){t=0;g=0;}, update(dt){
    t+=dt; g+=dt;
    if(g>=rate){g=0; const cols=5, step=ARENA.w/(cols+1), i=1+Math.floor(Math.random()*cols);
      const x=ARENA.x + i*step + (Math.random()*14-7);
      spawn({x,y:ARENA.y-22,vx:0,vy:300,r:5,col:'#9b86d6',dmg});
      // trailing orb
      spawn({x,y:ARENA.y-22-20,vx:0,vy:240,r:3,col:'#d8cdfa',dmg:Math.max(3,Math.floor(dmg*0.6))});
    }
  }, done(){return t>=duration;}};
}
function patOrbitals(duration=5, dmg=4){
  // Orbiting balls around center that occasionally shoot at you
  let t=0, a0=Math.random()*Math.PI*2, shoot=0;
  const cx=ARENA.x+ARENA.w/2, cy=ARENA.y+ARENA.h/2, R=Math.min(ARENA.w,ARENA.h)*0.42;
  let orbs=[];
  return {enter(){t=0; shoot=0; orbs=[]; for(let i=0;i<5;i++){orbs.push({ang:a0+i*(Math.PI*2/5)});} },
    update(dt){
      t+=dt; shoot+=dt;
      for(const o of orbs){o.ang += 1.6*dt;}
      if(shoot>=0.5){shoot=0;
        for(const o of orbs){
          const ox=cx+Math.cos(o.ang)*R, oy=cy+Math.sin(o.ang)*R;
          spawnAimed(ox,oy,240,dmg,'#cab6ff',3);
        }
      }
    },
    done(){return t>=duration;}
  };
}
function patShadePressure(duration=7){
  const A=patVoidSlash(duration,7), B=patShadowHoming(duration,6), C=patOrbitals(duration,4);
  return {enter(){A.enter();B.enter();C.enter();}, update(dt){A.update(dt);B.update(dt);C.update(dt);}, done(){return false;}};
}

/* ===== Attack phase wrapper ===== */
function phase(duration, ...parts){
  let t=0;
  return {
    enter(){t=0; parts.forEach(p=>p.enter&&p.enter());},
    update(dt){t+=dt; parts.forEach(p=>p.update&&p.update(dt));},
    done(){return t>=duration;}
  };
}

/* ===== Flow ===== */
function setBoss(idx){
  bossIndex=idx;
  const data=BOSSES[bossIndex];
  BOSS={name:data.name, hpMax:data.hpMax, hp:data.hpMax, draw:data.draw, makeAttacks:data.attacks};
  bossNameEl.textContent=BOSS.name;
  bossBar();
  // build fresh attack sequence
  attackIx=0;
  attackSeq = BOSS.makeAttacks();
}
function bossHit(dmg){
  BOSS.hp=Math.max(0,BOSS.hp-dmg);
  bossBar();
  damagePopup={x:480,y:200,t:0,text:String(dmg)};
}
function endPlayerTurn(){
  setTimeout(()=>{
    turn='enemy';
    uiCenter.textContent='Enemy turn';
    uiBar.classList.add('hidden');
    hideBubble();
    startAttack();
  },220);
}
let attackSeq=null;
function startAttack(){
  bullets.length=0; phaseT=0; showArena=true; boxEl.style.display='block';
  attack = attackSeq[attackIx];
  attackIx = (attackIx+1) % attackSeq.length;
  attack.enter();
}
function finishAttack(){
  turn='player';
  uiCenter.textContent='Your turn';
  showArena=false; boxEl.style.display='none';
  uiBar.classList.remove('hidden');
  restoreBubble();
}
function defeat(){
  // Reset current boss to full and restart from this boss
  showBubble('You fall. The hall dims.');
  setTimeout(()=>initBoss(bossIndex),1100);
}
function victory(){
  // Next boss or ending
  showBubble('The rite ends. The hall exhales.');
  setTimeout(()=>{
    if(bossIndex+1 < BOSSES.length){
      initBoss(bossIndex+1);
    }else{
      initBoss(0); // loop back or show final screen
    }
  },1000);
}

function initBoss(idx){
  setBoss(idx);
  HEART.hp=50; HEART.i=0;
  HEART.x=ARENA.x+ARENA.w/2; HEART.y=ARENA.y+ARENA.h/2;
  updatePlayerHP();
  turn='player'; uiCenter.textContent='Your turn'; showArena=false; boxEl.style.display='none';
  uiBar.classList.remove('hidden');
  showBubble(BOSSES[bossIndex].intro.join('\n'));
}

/* ===== Init ===== */
initBoss(0);

/* ===== Loop ===== */
let last=performance.now();
function loop(now){
  const dt=Math.min(0.033,(now-last)/1000); last=now;
  if(!paused){ update(dt); render(dt); }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ===== Update ===== */
function update(dt){
  time+=dt;

  if(turn==='enemy'){
    phaseT+=dt;

    // movement
    let dx=0,dy=0;
    if(key('ArrowLeft')||key('a')) dx-=1;
    if(key('ArrowRight')||key('d')) dx+=1;
    if(key('ArrowUp')||key('w')) dy-=1;
    if(key('ArrowDown')||key('s')) dy+=1;
    const L=Math.hypot(dx,dy)||1;
    HEART.x=Math.max(ARENA.x+HEART.r, Math.min(ARENA.x+ARENA.w-HEART.r, HEART.x+dx/L*HEART.sp*dt));
    HEART.y=Math.max(ARENA.y+HEART.r, Math.min(ARENA.x+ARENA.h-HEART.r, HEART.y+dy/L*HEART.sp*dt)); // note: ARENA.x + ARENA.h is intentional? Fix:
    HEART.y=Math.max(ARENA.y+HEART.r, Math.min(ARENA.y+ARENA.h-HEART.r, HEART.y));
    HEART._pdt=dt; HEART._px=HEART.x; HEART._py=HEART.y;
    HEART.i=Math.max(0,HEART.i-dt);

    // attack update
    if(attack) attack.update(dt);

    // bullets
    for(const b of bullets){ b.t+=dt; b.x+=b.vx*dt; b.y+=b.vy*dt; }
    bullets=bullets.filter(b=>b.x>ARENA.x-140 && b.x<ARENA.x+ARENA.w+140 && b.y>ARENA.y-140 && b.y<ARENA.y+ARENA.h+160);

    // collisions
    for(const b of bullets){
      const dx2=b.x-HEART.x, dy2=b.y-HEART.y, rr=(b.r||4)+HEART.r;
      if(dx2*dx2+dy2*dy2<=rr*rr && HEART.i<=0){
        const dmg=Math.max(1,Math.floor(b.dmg||5));
        HEART.hp=Math.max(0,HEART.hp - dmg);
        updatePlayerHP();
        HEART.i=0.85;
      }
    }

    // end phase
    if(attack && attack.done()){
      finishAttack();
    }

    // defeat
    if(HEART.hp<=0){
      turn='defeat';
      defeat();
    }
  }

  // victory check
  if(BOSS && BOSS.hp<=0 && turn!=='victory'){
    turn='victory'; showArena=false; boxEl.style.display='none';
    victory();
  }

  // popup decay
  if(damagePopup){ damagePopup.t+=dt; if(damagePopup.t>0.9) damagePopup=null; }
}

/* ===== Render ===== */
function render(dt){
  // background
  ctx.fillStyle='#0b0907'; ctx.fillRect(0,0,960,720);
  ctx.fillStyle='#1a130f';
  for(let i=0;i<96;i++){const x=(i*97)%960, y=(i*151)%720; ctx.fillRect(x,y,2,2);}

  // current boss sprite
  if(BOSS && typeof BOSS.draw==='function'){ BOSS.draw(ctx,time,scene.flinch); }

  // arena on enemy turn
  if(turn==='enemy' && showArena){
    ctx.strokeStyle='#ffffff'; ctx.lineWidth=3; ctx.strokeRect(ARENA.x,ARENA.y,ARENA.w,ARENA.h);

    // bullets
    for(const b of bullets){ ctx.fillStyle=b.col||'#fff'; ctx.beginPath(); ctx.arc(b.x,b.y,b.r||4,0,Math.PI*2); ctx.fill(); }

    // heart
    ctx.save(); if(HEART.i>0) ctx.globalAlpha=0.6+0.3*Math.sin(time*20);
    drawHeart(ctx,HEART.x-6,HEART.y-6,'#ffd166',0.8);
    ctx.restore();
  }

  // damage popup
  if(damagePopup){
    const a=Math.max(0,1-damagePopup.t/0.9);
    ctx.save(); ctx.globalAlpha=a; ctx.fillStyle='#fff1b6'; ctx.font='16px monospace';
    ctx.fillText(damagePopup.text, damagePopup.x, damagePopup.y - damagePopup.t*60);
    ctx.restore();
  }
}

/* ===== Utility: input poll ===== */
function key(k){return down.has(k)||down.has(k.toUpperCase());}
</script>
</body>
</html>

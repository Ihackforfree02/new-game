<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>battle.html â€” Bullet Heart Run: Meme Boss Edition (Fixed)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root{
  --bg:#07060a; --panel:#111; --neon:#33f7ff; --accent:#ffd166; --danger:#ff5c5c;
  --ui:#1b1b1b; --muted:#9aa;
}
html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:monospace;display:flex;align-items:center;justify-content:center;}
#container{position:relative;width:960px;height:720px;box-shadow:0 0 0 6px #000 inset,0 20px 80px rgba(0,0,0,0.6);}
canvas{display:block;background:linear-gradient(180deg,#05050a 0%,#0b0b10 100%);width:960px;height:720px;image-rendering:pixelated}
#adminPanel{position:absolute;top:12px;left:50%;transform:translateX(-50%);background:var(--panel);padding:10px;border:2px solid var(--accent);display:none;z-index:50;border-radius:6px;}
#adminPanel button,#adminPanel select{margin:6px 6px 0 0;padding:6px;background:#000;border:1px solid #333;color:#fff;border-radius:4px;}
#equip{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:var(--ui);padding:12px;border:2px solid #fff;display:none;z-index:40;border-radius:6px;}
#equip button{margin-top:8px;padding:6px 10px;background:#000;border:1px solid #333;color:#fff;border-radius:4px;}
#hud{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,0.45);padding:8px;border-radius:6px;border:1px solid #222;font-size:14px;z-index:45;}
#controlsHint{position:absolute;right:12px;bottom:12px;background:rgba(0,0,0,0.4);padding:8px;border-radius:6px;border:1px solid #222;font-size:13px;z-index:45;color:var(--muted)}
.menu{position:absolute;left:50%;bottom:88px;transform:translateX(-50%);display:flex;gap:8px;z-index:46}
.menu .opt{padding:10px 18px;background:#111;border:2px solid #222;border-radius:6px;color:#fff;font-weight:bold;cursor:default;user-select:none}
.menu .sel{border-color:var(--neon);box-shadow:0 0 18px rgba(51,247,255,0.12);background:linear-gradient(180deg,#131313,#0b0b0b)}
.infoBox{position:absolute;left:50%;bottom:20px;transform:translateX(-50%);background:rgba(0,0,0,0.5);padding:6px 12px;border-radius:6px;border:1px solid #222;z-index:46}
.small{font-size:13px;color:var(--muted)}
</style>
</head>
<body>
<div id="container">
  <canvas id="game" width="960" height="720"></canvas>

  <div id="adminPanel" aria-hidden="true">
    <strong>Admin</strong><br/>
    <select id="bossSelect">
      <option value="shrek">Shrekonator</option>
      <option value="cheesus">Cheesus</option>
      <option value="cluck">Cluckthulhu</option>
    </select>
    <button id="btnSpawnBoss">Spawn Boss</button>
    <button id="btnSpawnChest">Spawn Chest</button>
    <button id="btnHeal">Heal Player</button>
    <button id="btnWin">Kill Boss</button>
  </div>

  <div id="equip" aria-hidden="true">
    <strong>Equip</strong>
    <div style="margin-top:8px">Weapon: <span id="wepCur">Banana Blade</span></div>
    <div style="margin-top:6px">Buffs: <span id="buffCur">None</span></div>
    <div style="margin-top:8px">
      <button onclick="equipWeapon('Banana Blade',6)">Banana Blade (6)</button>
      <button onclick="equipWeapon('Laser Katana',12)">Laser Katana (12)</button>
      <button onclick="applyBuff('Rage Tonic')">Use Rage Tonic</button>
    </div>
    <button onclick="closeEquip()">Close</button>
  </div>

  <div id="hud">
    <span id="txtLV">LV 1</span> &nbsp; <span id="txtGold">G: 0</span> &nbsp;
    <span id="txtHP">HP: 20/20</span> &nbsp; <span id="txtBoss">Boss: None</span>
  </div>

  <div class="menu" id="menu">
    <div class="opt sel" data-i="0">FIGHT</div>
    <div class="opt" data-i="1">ACT</div>
    <div class="opt" data-i="2">EQUIP</div>
    <div class="opt" data-i="3">MERCY</div>
  </div>

  <div class="infoBox small" id="info">Arrow keys to move in dodge phases. Arrow keys + Enter to choose menu option. E to open Equip.</div>

  <div id="controlsHint">Arrows: Move &nbsp; Enter: Confirm &nbsp; E: Equip &nbsp; Type 676767 to open Admin</div>
</div>

<script>
/* ---------------------------
   Fixed final version based on your file
   - Uses only additions/changes inside this file
   - Implements full fight/dodge flow, act/equip/mercy, stronger attacks
   - Admin panel works
   --------------------------- */

/* Core */
const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
let last = performance.now(), dt = 0, acc = 0;
let keys = new Set();
let mouse = {x:0,y:0};
document.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
  mouse.y = (e.clientY - r.top) * (canvas.height / r.height);
});
document.addEventListener('keydown', e => {
  keys.add(e.key);
  adminSeqHandler(e.key);
  if(e.key==='e' || e.key==='E') toggleEquip(true);
  if(e.key==='Enter') onConfirm();
});
document.addEventListener('keyup', e => keys.delete(e.key));

/* Player & HUD */
let player = { x: W/2, y: H-140, r:8, hp:20, maxHp:20, lv:1, gold:0, weapon:{name:'Banana Blade', dmg:6}, buffs:[] };
const hudHP = document.getElementById('txtHP'), hudGold = document.getElementById('txtGold'), hudLV = document.getElementById('txtLV'), hudBoss = document.getElementById('txtBoss');
const wepCur = document.getElementById('wepCur'), buffCur = document.getElementById('buffCur');

/* Game objects */
let bullets = [], chests = [];
let boss = null;
let flow = 'player-menu'; // player-menu | player-dodge | enemy | victory
let menuIndex = 0;

/* Constants */
const SPEED = 240;
const BULLET_LIFE = 8;

/* Admin */
let adminSequence = '', adminOpen = false;
const adminPanel = document.getElementById('adminPanel');
document.getElementById('btnSpawnBoss').onclick = () => spawnBoss(document.getElementById('bossSelect').value);
document.getElementById('btnSpawnChest').onclick = () => spawnChest();
document.getElementById('btnHeal').onclick = () => { player.hp = player.maxHp; updateHUD(); };
document.getElementById('btnWin').onclick = () => { if(boss) boss.hp = 0; };

function adminSeqHandler(key){
  adminSequence += key;
  adminSequence = adminSequence.slice(-20);
  if(!adminOpen && adminSequence.replace(/[^67]/g,'').endsWith('676767')){
    adminOpen = true; adminPanel.style.display = 'block'; alert('Admin Panel unlocked');
  }
}

/* Boss definitions (stronger attacks) */
const BOSS_DEFS = {
  shrek: {
    id:'shrek', name:'Shrekonator', hp:220, color:'#37a83a',
    intro:'SHREKONATOR: SWAMP PROTOCOL',
    actPhrases:['Offer onion','Sing ogre song','Compliment toes'],
    pattern(self){
      // heavy spread
      if(Math.random() < 0.04){
        const n = 10;
        for(let i=0;i<n;i++){
          const a = (i/n)*Math.PI*2 + rand(-0.22,0.22);
          bullets.push(bullet(self.x + Math.cos(a)*48, self.y + Math.sin(a)*48, Math.cos(a)*180, Math.sin(a)*180, 6, '#3fd'));
        }
      }
      // homing mud
      if(Math.random() < 0.025){
        const ang = Math.atan2(player.y-self.y, player.x-self.x) + rand(-0.5,0.5);
        bullets.push(homing(self.x,self.y,Math.cos(ang)*120,Math.sin(ang)*120,12,'#3f3',0.55));
      }
    }
  },
  cheesus: {
    id:'cheesus', name:'Cheesus', hp:180, color:'#ffdf5b',
    intro:'CHEESUS: BLESSED FROM THE DAIRY',
    actPhrases:['Praise slice','Offer cracker','Warm fondue'],
    pattern(self){
      if(Math.random() < 0.045){
        const n = 14;
        for(let i=0;i<n;i++){
          const a = (i/n)*Math.PI*2 + rand(-0.1,0.1);
          bullets.push(bullet(self.x + Math.cos(a)*36, self.y + Math.sin(a)*36, Math.cos(a)*160, Math.sin(a)*160, 4, '#ffd'));
        }
      }
      if(Math.random() < 0.035){
        const rows = 4;
        for(let r=0;r<rows;r++){
          const y = 140 + r*20 + rand(-6,6);
          bullets.push(straight(60 + rand(-10,10), y, 320, 0, 10, '#ffd166'));
          bullets.push(straight(W-60 + rand(-10,10), y+8, -320, 0, 10, '#ffd166'));
        }
      }
    }
  },
  cluck: {
    id:'cluck', name:'Cluckthulhu', hp:260, color:'#fff1f0',
    intro:'CLUCKTHULHU: THE COSMIC CHICKEN',
    actPhrases:['Feed worm','Hum tune','Cluck softly'],
    pattern(self){
      if(Math.random() < 0.035){
        const center = {x:480 + rand(-220,220), y:200 + rand(-40,40)};
        for(let i=0;i<12;i++){
          const a = rand(0,Math.PI*2);
          bullets.push(orbit(center.x + Math.cos(a)*34, center.y + Math.sin(a)*34, rand(-160,160), rand(-160,160), 6, '#f8f'));
        }
      }
      if(Math.random() < 0.03){
        const n = 12;
        for(let i=0;i<n;i++){
          const a = (i/n)*Math.PI*2 + rand(-0.2,0.2);
          bullets.push(bullet(self.x + Math.cos(a)*60, self.y + Math.sin(a)*60, Math.cos(a)*230, Math.sin(a)*230, 6, '#f0f'));
        }
      }
    }
  }
};

/* Bullet factories */
function bullet(x,y,dx,dy,r,color){ return {x,y,dx,dy,r,color,life:BULLET_LIFE,type:'bullet',tick:0}; }
function homing(x,y,dx,dy,r,color,homing=0.6){ return {x,y,dx,dy,r,color,life:BULLET_LIFE,type:'homing',homing,tick:0}; }
function straight(x,y,dx,dy,r,color){ return {x,y,dx,dy,r,color,life:BULLET_LIFE,type:'straight',tick:0}; }
function orbit(x,y,dx,dy,r,color){ return {x,y,dx,dy,r,color,life:BULLET_LIFE,type:'orbit',tick:0,ang:rand(0,Math.PI*2)}; }

/* Utilities */
function rand(a,b){ return Math.random()*(b-a)+a; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(ax,ay,bx,by){ return Math.hypot(ax-bx,ay-by); }

/* Spawn, equip, chest */
function spawnChest(){ chests.push({x:rand(120,W-120), y:rand(180,H-220), opened:false}); }
function spawnBoss(key){ const def = BOSS_DEFS[key]; boss = { id:def.id, name:def.name, x:W/2, y:140, hp:def.hp, maxHp:def.hp, color:def.color, def:def, intro:120, pacified:0 }; bullets=[]; hudBoss.textContent = `Boss: ${boss.name}`; flow='player-menu'; }
function equipWeapon(name,dmg){ player.weapon = {name,dmg}; wepCur.textContent = name; closeEquip(); }
function applyBuff(name){ if(name==='Rage Tonic'){ player.buffs.push({name:'Rage Tonic', dmgMult:1.5, dur:90}); buffCur.textContent = player.buffs.map(b=>b.name).join(', '); closeEquip(); } }
function toggleEquip(show){ document.getElementById('equip').style.display = show ? 'block' : 'none'; }
function closeEquip(){ toggleEquip(false); }

/* Menu & interactions (Undertale-like) */
const menuEls = Array.from(document.querySelectorAll('.menu .opt'));
function updateMenuVisual(){ menuEls.forEach((el,i)=>el.classList.toggle('sel', i===menuIndex)); }
function onConfirm(){ if(flow !== 'player-menu') return; const sel = menuIndex; if(sel===0) startFight(); else if(sel===1) startAct(); else if(sel===2) toggleEquip(true); else if(sel===3) startMercy(); }

/* Fight: triggers dodge phase then apply damage */
function startFight(){
  if(!boss) return;
  flow = 'player-dodge';
  // compute damage (weapon + buffs)
  player.pendingDamage = Math.floor(player.weapon.dmg * player.buffs.reduce((m,b)=>m*(b.dmgMult||1),1));
  const dodgeWindow = 1400;
  // while dodge window runs boss continues spawning bullets aggressively
  setTimeout(()=>{
    if(boss){ boss.hp -= player.pendingDamage; if(boss.hp < 0) boss.hp = 0; }
    player.pendingDamage = 0;
    flow = 'enemy';
    setTimeout(()=>{ if(boss && boss.hp>0) flow='player-menu'; else if(!boss) flow='victory'; }, 700);
  }, dodgeWindow);
}

/* ACT: interact to pacify or damage slightly */
function startAct(){
  if(!boss) return;
  const phrases = boss.def.actPhrases || ['...'];
  const choice = phrases[Math.floor(rand(0,phrases.length))];
  const success = Math.random() < 0.52;
  if(success){
    boss.pacified = (boss.pacified || 0) + 360;
    boss.hp = Math.max(1, boss.hp - 6);
    alert(`ACT: You "${choice}" â€” it helped.`);
  } else {
    alert(`ACT: You "${choice}" â€” nothing.`);
  }
  flow = 'enemy';
  setTimeout(()=>{ if(boss && boss.hp>0) flow='player-menu'; else if(!boss) flow='victory'; }, 700);
}

/* MERCY */
function startMercy(){
  if(!boss) return;
  const canSpare = (boss.hp <= boss.maxHp * 0.16) || (boss.pacified && boss.pacified > 0);
  if(canSpare){
    alert(`You spared ${boss.name}. You gain gold.`);
    player.gold += Math.floor(rand(30,100));
    boss = null; hudBoss.textContent = 'Boss: None'; flow = 'player-menu'; updateHUD();
  } else {
    alert('Mercy refused.');
    flow = 'enemy';
    setTimeout(()=>{ if(boss) flow='player-menu'; }, 600);
  }
}

/* Update loop */
function update(now){
  dt = (now - last)/1000; last = now; dt = Math.min(0.04, dt);
  acc += dt*1000;
  // menu nav
  if(flow === 'player-menu'){
    if(keys.has('ArrowLeft')){ menuIndex = (menuIndex+3)%4; updateMenuVisual(); keys.delete('ArrowLeft'); }
    if(keys.has('ArrowRight')){ menuIndex = (menuIndex+1)%4; updateMenuVisual(); keys.delete('ArrowRight'); }
    if(keys.has('ArrowUp')){ menuIndex = (menuIndex+3)%4; updateMenuVisual(); keys.delete('ArrowUp'); }
    if(keys.has('ArrowDown')){ menuIndex = (menuIndex+1)%4; updateMenuVisual(); keys.delete('ArrowDown'); }
  }

  // player movement allowed in dodge & enemy phases and normally
  if(flow !== 'player-menu' || flow === 'player-dodge'){
    let vx=0, vy=0;
    if(keys.has('ArrowLeft')) vx -= 1;
    if(keys.has('ArrowRight')) vx += 1;
    if(keys.has('ArrowUp')) vy -= 1;
    if(keys.has('ArrowDown')) vy += 1;
    const m = Math.hypot(vx,vy) || 1;
    player.x += (vx/m) * SPEED * dt;
    player.y += (vy/m) * SPEED * dt;
    player.x = clamp(player.x, 20, W-20);
    player.y = clamp(player.y, 120, H-30);
  }

  // boss logic
  if(boss){
    if(boss.intro > 0){ boss.intro -= 1; }
    else {
      const pacified = boss.pacified && boss.pacified > 0;
      if(boss.pacified) boss.pacified = Math.max(0, boss.pacified - 1);
      const aggression = (flow === 'enemy' || flow === 'player-dodge') ? 1.0 : 0.6;
      if(!pacified){
        if(Math.random() < 0.045 * aggression) boss.def.pattern(boss);
      } else {
        if(Math.random() < 0.01 * aggression) boss.def.pattern(boss);
      }
      boss.y = 120 + Math.sin(acc*0.002 + boss.id.length) * 8;
    }
  }

  // update bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.tick += dt; b.life -= dt;
    if(b.type === 'homing'){
      const ang = Math.atan2(player.y - b.y, player.x - b.x);
      const spd = Math.hypot(b.dx,b.dy) || 1;
      b.dx = (1-b.homing) * b.dx + b.homing * Math.cos(ang) * spd;
      b.dy = (1-b.homing) * b.dy + b.homing * Math.sin(ang) * spd;
      b.x += b.dx * dt; b.y += b.dy * dt;
    } else if(b.type === 'orbit'){
      b.ang += dt * 4;
      b.x += b.dx * dt * 0.2 + Math.cos(b.ang)*20*dt;
      b.y += b.dy * dt * 0.2 + Math.sin(b.ang)*20*dt;
    } else {
      b.x += b.dx * dt; b.y += b.dy * dt;
    }
    if(b.life <= 0 || b.x < -60 || b.x > W+60 || b.y < -60 || b.y > H+60){ bullets.splice(i,1); continue; }
    // collision with player
    if(dist(b.x,b.y,player.x,player.y) < b.r + player.r){
      const dmg = Math.max(1, Math.floor(b.r/3));
      player.hp -= dmg;
      bullets.splice(i,1);
      if(player.hp <= 0){ player.hp = 0; setTimeout(()=>playerRespawn(), 800); }
    }
  }

  // buffs duration
  for(let i=player.buffs.length-1;i>=0;i--){
    const bf = player.buffs[i];
    if(bf.dur){ bf.dur -= dt*60; if(bf.dur <= 0) player.buffs.splice(i,1); }
  }

  // boss death
  if(boss && boss.hp <= 0){
    alert(`${boss.name} defeated!`);
    player.gold += Math.floor(rand(60,200));
    boss = null; hudBoss.textContent = 'Boss: None'; flow = 'player-menu'; updateHUD();
  }

  // finished frame
  draw();
  updateHUD();
  requestAnimationFrame(update);
}

/* Draw */
function draw(){
  ctx.clearRect(0,0,W,H);
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#081026'); g.addColorStop(1,'#05040a'); ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  ctx.globalAlpha = 0.06; ctx.fillStyle = '#0ff';
  for(let i=0;i<6;i++){ const y = ((acc*0.02)+i*120) % H; ctx.fillRect(0,y,W,1); }
  ctx.globalAlpha = 1;
  ctx.fillStyle = 'rgba(50,50,80,0.12)'; ctx.fillRect(40,60,W-80,H-150);

  // draw chests
  for(const c of chests){
    ctx.fillStyle = c.opened ? '#666' : '#ffcc66';
    roundRect(ctx,c.x-14,c.y-10,28,20,4,true,false);
    ctx.strokeStyle = '#000'; ctx.strokeRect(c.x-14,c.y-10,28,20);
  }

  // bullets
  for(const b of bullets){
    ctx.beginPath(); ctx.fillStyle = b.color || '#f55'; ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.globalAlpha = 0.14; ctx.fillStyle = b.color || '#f55'; ctx.arc(b.x,b.y,b.r*2.6,0,Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
  }

  // boss
  if(boss){
    ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.ellipse(boss.x,boss.y+36,84,22,0,0,Math.PI*2); ctx.fill();
    drawBoss(boss);
    const bw = 560; const bp = clamp(boss.hp/boss.maxHp,0,1); const bx = (W-bw)/2, by = 26;
    ctx.fillStyle = '#222'; roundRect(ctx,bx,by,bw,14,6,true,false);
    ctx.fillStyle = boss.color || '#ffd166'; roundRect(ctx,bx+2,by+2,(bw-4)*bp,10,4,true,false);
    ctx.strokeStyle = '#000'; ctx.strokeRect(bx,by,bw,14);
    if(boss.intro > 0){ ctx.fillStyle = '#fff'; ctx.font = '18px monospace'; ctx.fillText(boss.def.intro, W/2 - ctx.measureText(boss.def.intro).width/2, by+40); }
  }

  // player heart
  drawHeart(player.x, player.y, player.r);
}

/* Draw helpers */
function drawBoss(b){
  ctx.save(); ctx.translate(b.x,b.y);
  ctx.fillStyle = b.color; ctx.beginPath(); ctx.ellipse(0,0,64,52,0,0,Math.PI*2); ctx.fill();
  if(b.id==='shrek'){
    ctx.fillStyle = '#2a2a2a'; ctx.fillRect(-28,-20,14,10); ctx.fillRect(14,-20,14,10);
    ctx.fillStyle = '#091'; ctx.fillRect(-16,-10,32,16);
    ctx.fillStyle = '#fff'; ctx.fillRect(-20,14,8,8); ctx.fillRect(12,14,8,8);
  } else if(b.id==='cheesus'){
    ctx.fillStyle = '#f7c94f'; for(let i=0;i<10;i++){ ctx.beginPath(); ctx.arc(rand(-36,36), rand(-24,24), rand(3,8), 0, Math.PI*2); ctx.fillStyle = '#e0a800'; ctx.fill(); }
    ctx.fillStyle = '#fff'; ctx.fillRect(-22,-12,44,8);
  } else if(b.id==='cluck'){
    ctx.fillStyle = '#ff6'; ctx.beginPath(); ctx.moveTo(0,-22); ctx.lineTo(28,2); ctx.lineTo(0,12); ctx.fill();
    ctx.fillStyle = '#222'; ctx.fillRect(-24,-16,14,10); ctx.fillRect(-24,4,14,10);
  }
  ctx.globalAlpha = 0.12; ctx.fillStyle = b.color || '#fff'; ctx.beginPath(); ctx.ellipse(0,0,100,80,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
  ctx.restore();
}
function drawHeart(x,y,r){
  ctx.save(); ctx.translate(x,y);
  ctx.fillStyle = '#fff'; roundRect(ctx, -r-1, -r-1, r*2+2, r*2+2, 4, true, false);
  ctx.fillStyle = '#ff4d4d'; ctx.beginPath(); ctx.moveTo(0, r/1.2); ctx.bezierCurveTo(r*1.6, r/1.4, r*1.6, -r*1.1, 0, -r*1.8); ctx.bezierCurveTo(-r*1.6, -r*1.1, -r*1.6, r/1.4, 0, r/1.2); ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.12)'; ctx.beginPath(); ctx.ellipse(-r*0.3, -r*0.6, r*0.5, r*0.3, 0, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}
function roundRect(ctx,x,y,w,h,r,fill,stroke){ if(r===undefined) r=5; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill) ctx.fill(); if(stroke) ctx.stroke(); }

/* Game utilities */
function updateHUD(){ hudHP.textContent = `HP: ${Math.max(0,Math.floor(player.hp))}/${player.maxHp}`; hudGold.textContent = `G: ${player.gold||0}`; hudLV.textContent = `LV ${player.lv}`; hudBoss.textContent = boss ? `Boss: ${boss.name}` : 'Boss: None'; wepCur.textContent = player.weapon.name; buffCur.textContent = player.buffs.length ? player.buffs.map(x=>x.name).join(', ') : 'None'; updateMenuVisual(); }
function updateMenuVisual(){ Array.from(document.querySelectorAll('.menu .opt')).forEach((el,i)=>el.classList.toggle('sel', i===menuIndex)); }
function playerRespawn(){ player.x = W/2; player.y = H-140; player.hp = player.maxHp; updateHUD(); }

/* Confirm (Enter) handler used for menu and chest open */
function onConfirm(){
  if(flow === 'player-menu'){ onConfirmMenu(); return; }
  // else if near chest, open handled in keydown Enter elsewhere; we check proximity too
  for(const c of chests){ if(!c.opened && dist(player.x,player.y,c.x,c.y) < 36){ c.opened = true; player.gold += Math.floor(rand(8,40)); if(Math.random() < 0.22){ player.weapon = {name:'Laser Katana', dmg:12}; wepCur.textContent = 'Laser Katana'; alert('Found Laser Katana!'); } else if(Math.random() < 0.17){ player.buffs.push({name:'Rage Tonic', dmgMult:1.5, dur:90}); buffCur.textContent = player.buffs.map(b=>b.name).join(', '); alert('Found Rage Tonic!'); } else alert('Found gold!'); updateHUD(); break; } }
}
function onConfirmMenu(){ if(flow !== 'player-menu') return; const sel = menuIndex; if(sel===0) startFight(); else if(sel===1) startAct(); else if(sel===2) toggleEquip(true); else if(sel===3) startMercy(); }

/* Fight/Act/Mercy implementations (already wired earlier, but ensure they use current variables) */
function startFight(){ if(!boss) return; flow = 'player-dodge'; player.pendingDamage = Math.floor(player.weapon.dmg * player.buffs.reduce((m,b)=>m*(b.dmgMult||1),1)); const dodgeWindow = 1400; setTimeout(()=>{ if(boss){ boss.hp -= player.pendingDamage; if(boss.hp < 0) boss.hp = 0; } player.pendingDamage = 0; flow = 'enemy'; setTimeout(()=>{ if(boss && boss.hp>0) flow='player-menu'; else if(!boss) flow='victory'; },700); }, dodgeWindow); }
function startAct(){ if(!boss) return; const phrases = boss.def.actPhrases || ['...']; const choice = phrases[Math.floor(rand(0,phrases.length))]; const success = Math.random() < 0.52; if(success){ boss.pacified = (boss.pacified || 0) + 360; boss.hp = Math.max(1, boss.hp - 6); alert(`ACT: You "${choice}" â€” it helped.`); } else { alert(`ACT: You "${choice}" â€” nothing.`); } flow='enemy'; setTimeout(()=>{ if(boss && boss.hp>0) flow='player-menu'; else if(!boss) flow='victory'; },700); }
function startMercy(){ if(!boss) return; const canSpare = (boss.hp <= boss.maxHp * 0.16) || (boss.pacified && boss.pacified > 0); if(canSpare){ alert(`You spared ${boss.name}. You gain gold.`); player.gold += Math.floor(rand(30,100)); boss = null; hudBoss.textContent = 'Boss: None'; flow = 'player-menu'; updateHUD(); } else { alert('Mercy refused.'); flow = 'enemy'; setTimeout(()=>{ if(boss) flow='player-menu'; },600); } }

/* Keyboard chest open helper (Enter also does chest open above) handled by onConfirm */

/* Start/loop */
function start(){
  last = performance.now(); requestAnimationFrame(update);
}
requestAnimationFrame(update);

/* Helper functions in patterns */
function spawnChest(){ chests.push({x:rand(120,W-120), y:rand(180,H-220), opened:false}); }
function spawnBoss(key){ spawnBossInternal(key); }
function spawnBossInternal(key){ const def = BOSS_DEFS[key]; boss = { id:def.id, name:def.name, x:W/2, y:140, hp:def.hp, maxHp:def.hp, color:def.color, def:def, intro:120, pacified:0 }; bullets=[]; hudBoss.textContent = `Boss: ${boss.name}`; flow='player-menu'; }

/* Implementations used in patterns that were referenced earlier */
function spawnBulletAt(x,y,angle,speed,rad,color){ bullets.push(bullet(x,y,Math.cos(angle)*speed,Math.sin(angle)*speed,rad,color)); }

/* Utilities for patterns compatibility */
function makeStraightFactory(x,y,dx,dy,r,color){ return {x,y,dx,dy,r,color,life:BULLET_LIFE,type:'straight',tick:0}; }
/* Short alias exposures required earlier */
function makeBullet(x,y,dx,dy,r,color){ return bullet(x,y,dx,dy,r,color); }

/* small utility */
function updateHUD(){ hudHP.textContent = `HP: ${Math.max(0,Math.floor(player.hp))}/${player.maxHp}`; hudGold.textContent = `G: ${player.gold||0}`; hudLV.textContent = `LV ${player.lv}`; hudBoss.textContent = boss ? `Boss: ${boss.name}` : 'Boss: None'; wepCur.textContent = player.weapon.name; buffCur.textContent = player.buffs.length ? player.buffs.map(x=>x.name).join(', ') : 'None'; updateMenuVisual(); }

/* Expose admin functions for button handlers and consoles */
window.spawnChest = spawnChest;
window.spawnBossInternal = spawnBossInternal;
window.equipWeapon = equipWeapon;
window.applyBuff = applyBuff;
window.closeEquip = closeEquip;

/* Misc small helpers and missing references used earlier */
function equipWeapon(name,dmg){ player.weapon = {name,dmg}; wepCur.textContent = name; closeEquip(); }
function applyBuff(name){ if(name === 'Rage Tonic'){ player.buffs.push({name:'Rage Tonic', dmgMult:1.5, dur:90}); buffCur.textContent = player.buffs.map(b=>b.name).join(', '); closeEquip(); } }
function closeEquip(){ toggleEquip(false); }

/* spawn initial items/boss for demo */
spawnChest(); spawnChest(); spawnBossInternal('shrek'); updateHUD();

/* Utility aliases to satisfy patterns or external calls */
function makeHoming(x,y,dx,dy,r,color,homing){ return homingFactory(x,y,dx,dy,r,color,homing); }
function homingFactory(x,y,dx,dy,r,color,homing){ return homing(x,y,dx,dy,r,color,homing); }
function makeOrbit(x,y,dx,dy,r,color){ return orbit(x,y,dx,dy,r,color); }

/* End of modifications and reconciliation of functions */

/* Basic helper functions used by patterns and loop (defined again to ensure present) */
function rand(a,b){ return Math.random()*(b-a)+a; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(ax,ay,bx,by){ return Math.hypot(ax-bx,ay-by); }

/* Main loop body updated above references */
function update(now){
  dt = (now - last)/1000; last = now; dt = Math.min(0.04, dt);
  acc += dt*1000;

  // menu navigation
  if(flow === 'player-menu'){
    if(keys.has('ArrowLeft')){ menuIndex = (menuIndex+3)%4; updateMenuVisual(); keys.delete('ArrowLeft'); }
    if(keys.has('ArrowRight')){ menuIndex = (menuIndex+1)%4; updateMenuVisual(); keys.delete('ArrowRight'); }
    if(keys.has('ArrowUp')){ menuIndex = (menuIndex+3)%4; updateMenuVisual(); keys.delete('ArrowUp'); }
    if(keys.has('ArrowDown')){ menuIndex = (menuIndex+1)%4; updateMenuVisual(); keys.delete('ArrowDown'); }
  }

  // movement
  if(flow !== 'player-menu' || flow === 'player-dodge'){
    let vx=0, vy=0;
    if(keys.has('ArrowLeft')) vx -= 1;
    if(keys.has('ArrowRight')) vx += 1;
    if(keys.has('ArrowUp')) vy -= 1;
    if(keys.has('ArrowDown')) vy += 1;
    const m = Math.hypot(vx,vy) || 1;
    player.x += (vx/m) * SPEED * dt;
    player.y += (vy/m) * SPEED * dt;
    player.x = clamp(player.x,20,W-20);
    player.y = clamp(player.y,120,H-30);
  }

  // boss logic and patterns
  if(boss){
    if(boss.intro > 0){ boss.intro -= 1; }
    else {
      const pacified = boss.pacified && boss.pacified > 0;
      if(boss.pacified) boss.pacified = Math.max(0, boss.pacified - 1);
      const aggression = (flow === 'enemy' || flow === 'player-dodge') ? 1.0 : 0.6;
      if(!pacified){
        if(Math.random() < 0.045 * aggression) boss.def.pattern(boss);
      } else {
        if(Math.random() < 0.01 * aggression) boss.def.pattern(boss);
      }
      boss.y = 120 + Math.sin(acc*0.002 + boss.id.length) * 8;
    }
  }

  // bullets update
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.tick = (b.tick || 0) + dt; b.life = (b.life === undefined ? BULLET_LIFE : b.life) - dt;
    if(b.type === 'homing'){
      const ang = Math.atan2(player.y - b.y, player.x - b.x);
      const spd = Math.hypot(b.dx,b.dy) || 1;
      b.dx = (1-b.homing) * b.dx + b.homing * Math.cos(ang) * spd;
      b.dy = (1-b.homing) * b.dy + b.homing * Math.sin(ang) * spd;
      b.x += b.dx * dt; b.y += b.dy * dt;
    } else if(b.type === 'orbit'){
      b.ang = (b.ang || 0) + dt * 4;
      b.x += b.dx * dt * 0.2 + Math.cos(b.ang)*20*dt;
      b.y += b.dy * dt * 0.2 + Math.sin(b.ang)*20*dt;
    } else {
      b.x += b.dx * dt; b.y += b.dy * dt;
    }
    if(b.life <= 0 || b.x < -60 || b.x > W+60 || b.y < -60 || b.y > H+60){ bullets.splice(i,1); continue; }
    if(dist(b.x,b.y,player.x,player.y) < b.r + player.r){
      const dmg = Math.max(1, Math.floor(b.r/3));
      player.hp -= dmg;
      bullets.splice(i,1);
      if(player.hp <= 0){ player.hp = 0; setTimeout(()=>playerRespawn(), 800); }
    }
  }

  // buffs
  for(let i=player.buffs.length-1;i>=0;i--){
    const bf = player.buffs[i];
    if(bf.dur){ bf.dur -= dt*60; if(bf.dur <= 0) player.buffs.splice(i,1); }
  }

  // boss defeat
  if(boss && boss.hp <= 0){
    alert(`${boss.name} defeated!`);
    player.gold += Math.floor(rand(60,200));
    boss = null; hudBoss.textContent = 'Boss: None'; flow = 'player-menu'; updateHUD();
  }

  // render after update
  draw();
  updateHUD();

  requestAnimationFrame(update);
}

/* Start the loop */
last = performance.now();
requestAnimationFrame(update);

/* Utility re-exports */
window.spawnChest = spawnChest;
window.spawnBossInternal = spawnBossInternal;
window.equipWeapon = equipWeapon;
window.applyBuff = applyBuff;
window.closeEquip = closeEquip;

/* End of file */
</script>
</body>
</html>

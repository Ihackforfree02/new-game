<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Battle — stable with full self-tests (Solar + Cupcake)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<style>
html,body{margin:0;height:100%;background:#000;color:#ffd166;display:flex;align-items:center;justify-content:center;font-family:ui-monospace,Consolas,Menlo,monospace}
#wrap{width:960px;height:720px;position:relative;background:#0b0b10;border:4px solid #1a1a22;image-rendering:pixelated}

/* HUD */
#hud{position:absolute;left:0;right:0;top:0;padding:10px 16px;display:flex;justify-content:space-between;z-index:3}
.hcol{display:flex;flex-direction:column;gap:6px}
.bar{height:10px;background:#16161c;border:1px solid #2a2a33;position:relative}
.fill{position:absolute;left:0;top:0;bottom:0}
#bossFill{background:#ff5e6b;width:0}
#hpFill{background:#7affb7;width:0}
.sub{font-size:12px;color:#e6dcae}

/* Dialogue */
#bubble{position:absolute;left:50%;bottom:132px;transform:translateX(-50%);width:90%;min-height:88px;background:rgba(10,10,12,.86);border-radius:6px;border:2px solid #ffd166;padding:12px;display:none;z-index:3}
#bubbleText{white-space:pre-line;line-height:1.5}

/* Bottom UI */
#uiBar{position:absolute;left:50%;bottom:8px;transform:translateX(-50%);width:920px;height:92px;background:#111;border:2px solid #3a3a44;display:flex;align-items:center;justify-content:space-around;z-index:3}
.btn{cursor:pointer;user-select:none;display:flex;align-items:center;gap:10px}
.key{width:22px;height:22px;border:2px solid #fff;display:flex;align-items:center;justify-content:center;font-weight:700}
.lab{font-size:18px;letter-spacing:1px;min-width:88px}

/* Arena */
#arena{position:absolute;left:240px;top:418px;width:480px;height:184px;border:3px solid #fff;display:none;box-shadow:0 0 12px rgba(255,255,255,.35);z-index:2}

/* Test overlay */
#test{position:absolute;left:50%;top:18px;transform:translateX(-50%);min-width:360px;max-width:90%;background:#0f1218;border:1px solid #334;color:#cfe8ff;padding:10px;font-size:12px;border-radius:6px;display:none;z-index:5;white-space:pre-wrap}
.pass{border-color:#1f4; color:#d8ffe2}
.fail{border-color:#f41; color:#ffd6d6}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="cv" width="960" height="720"></canvas>

  <div id="hud">
    <div class="hcol" style="min-width:320px">
      <div id="bossName">—</div>
      <div class="bar" style="width:440px"><div id="bossFill" class="fill"></div></div>
      <div id="bossVal" class="sub">0/0</div>
    </div>
    <div class="hcol" style="align-items:flex-end;min-width:240px">
      <div id="playerName" style="color:#a7ffd2">Traveler</div>
      <div class="bar" style="width:260px"><div id="hpFill" class="fill"></div></div>
      <div id="hpVal" class="sub">60/60</div>
    </div>
  </div>

  <div id="bubble"><div id="bubbleText"></div></div>
  <div id="arena"></div>

  <div id="uiBar">
    <div class="btn" data-act="FIGHT"><div class="key">Z</div><div class="lab">FIGHT</div></div>
    <div class="btn" data-act="ACT"><div class="key">A</div><div class="lab">ACT</div></div>
    <div class="btn" data-act="ITEM"><div class="key">I</div><div class="lab">ITEM</div></div>
    <div class="btn" data-act="MERCY"><div class="key">M</div><div class="lab">MERCY</div></div>
  </div>

  <div id="test"></div>
</div>

<script>
"use strict";

/* Canvas */
const cv=document.getElementById('cv'), ctx=cv.getContext('2d',{alpha:false});
ctx.imageSmoothingEnabled=false;

/* UI elements */
const bossName=document.getElementById('bossName'), bossFill=document.getElementById('bossFill'), bossVal=document.getElementById('bossVal');
const hpFill=document.getElementById('hpFill'), hpVal=document.getElementById('hpVal');
const bubble=document.getElementById('bubble'), bubbleText=document.getElementById('bubbleText');
const uiBar=document.getElementById('uiBar'), arenaEl=document.getElementById('arena');
const testEl=document.getElementById('test');

/* Game state */
const ARENA={x:240,y:418,w:480,h:184};
const HEART={x:ARENA.x+ARENA.w/2,y:ARENA.y+ARENA.h/2,r:6,sp:320,i:0,hp:60,hpMax:60};
let bullets=[];
let time=0,last=performance.now();
let turn='player', showArena=false, attack=null, attackSeq=null, attackIx=0;
let BOSS=null, bossIndex=0;

/* Helpers */
function say(t){ bubble.style.display='block'; bubbleText.textContent=t; }
function hideSay(){ bubble.style.display='none'; }
function centerHeart(){ HEART.x=ARENA.x+ARENA.w/2; HEART.y=ARENA.y+ARENA.h/2; }

/* Bars */
function updateBossBar(){
  if(!BOSS) return;
  const r=Math.max(0,Math.min(1,BOSS.hp/BOSS.hpMax));
  bossFill.style.width=(440*r)+'px';
  bossVal.textContent=`${Math.floor(Math.max(0,BOSS.hp))}/${Math.floor(BOSS.hpMax)}`;
}
function updatePlayerBar(){
  const r=Math.max(0,Math.min(1,HEART.hp/HEART.hpMax));
  hpFill.style.width=(260*r)+'px';
  hpFill.style.background=r<0.25?'#ff5e6b':r<0.5?'#ffd166':'#7affb7';
  hpVal.textContent=`${Math.floor(Math.max(0,HEART.hp))}/${Math.floor(HEART.hpMax)}`;
}

/* Undertale SOUL */
function drawSOUL(x,y,scale=4,color='#ff0000'){
  const mask=["00100100","01111110","11111111","11111111","11111111","01111110","00111100","00011000"];
  ctx.save();
  ctx.globalAlpha=0.18; ctx.fillStyle=color; ctx.beginPath(); ctx.arc(x,y,scale*4.5,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
  ctx.translate(x-(mask[0].length*scale)/2,y-(mask.length*scale)/2); ctx.fillStyle=color;
  for(let r=0;r<mask.length;r++) for(let c=0;c<mask[r].length;c++) if(mask[r][c]==='1') ctx.fillRect(c*scale,r*scale,scale,scale);
  ctx.restore();
}

/* Boss visuals + backgrounds */
function bgSolar(){ const g=ctx.createLinearGradient(0,0,0,720); g.addColorStop(0,'#ffcc66'); g.addColorStop(1,'#cc6600'); ctx.fillStyle=g; ctx.fillRect(0,0,960,720); }
function drawSolar(t){ const cx=480, cy=240+Math.sin(t*2)*3; ctx.fillStyle='#ffd166'; ctx.beginPath(); ctx.arc(cx,cy,40,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#000'; const blink=(Math.sin(t*4)>0.9)?0:1; ctx.fillRect(cx-12,cy-10,6,blink*6); ctx.fillRect(cx+6,cy-10,6,blink*6); }

function bgCandy(){
  const grad=ctx.createLinearGradient(0,0,0,720); grad.addColorStop(0,'#ffccf9'); grad.addColorStop(1,'#ffe6f7'); ctx.fillStyle=grad; ctx.fillRect(0,0,960,720);
  ctx.strokeStyle='#ff99cc'; ctx.lineWidth=30; for(let x=-100;x<960;x+=120){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x+200,720); ctx.stroke(); }
  for(let i=0;i<5;i++){ const lx=100+i*180, ly=600; ctx.strokeStyle='#663300'; ctx.lineWidth=6; ctx.beginPath(); ctx.moveTo(lx,ly); ctx.lineTo(lx,ly-120); ctx.stroke();
    ctx.fillStyle=['#ff6666','#66ccff','#99ff99','#ffff66','#ff99ff'][i%5]; ctx.beginPath(); ctx.arc(lx,ly-140,40,0,Math.PI*2); ctx.fill(); }
}
function drawCupcake(t){ const cx=480, cy=240;
  ctx.fillStyle='#ff7acb'; ctx.beginPath(); ctx.moveTo(cx-40,cy+40); ctx.lineTo(cx+40,cy+40); ctx.lineTo(cx+30,cy+80); ctx.lineTo(cx-30,cy+80); ctx.closePath(); ctx.fill();
  ctx.fillStyle='#ffc3f3'; ctx.beginPath(); ctx.arc(cx,cy,40,Math.PI,0); ctx.arc(cx,cy-20,30,Math.PI,0); ctx.arc(cx,cy-40,20,Math.PI,0); ctx.fill();
  ctx.fillStyle='#ff3a6b'; ctx.beginPath(); ctx.arc(cx,cy-60+Math.sin(t*3)*2,10,0,Math.PI*2); ctx.fill();
  const colors=['#ff0000','#00ff00','#0000ff','#ffff00','#ff00ff','#00ffff']; for(let i=0;i<12;i++){ const a=t*2+i/12*Math.PI*2; const x=cx+Math.cos(a)*50; const y=cy-20+Math.sin(a)*30; ctx.fillStyle=colors[i%colors.length]; ctx.fillRect(x,y,4,8); }
}

/* Deterministic patterns (for tests) */
function phaseRain(dur=3,col='#fff',vy=300,band=12,rate=0.08){ let t=0,a=0; return {enter(){t=0;a=0},update(dt){t+=dt;a+=dt; while(a>=rate){a-=rate; for(let i=0;i<band;i++){ const x=ARENA.x+(i+0.5)*(ARENA.w/band); bullets.push({x,y:ARENA.y-16,vx:((i%2)?60:-60),vy:vy,r:3,col,dmg:5}); } }},done(){return t>=dur}}; }
function phaseWall(dur=3,col='#fff',vx=300,rows=8,rate=0.5){ let t=0,a=0,flip=false; return {enter(){t=0;a=0;flip=false},update(dt){t+=dt;a+=dt; while(a>=rate){a-=rate; const left=flip=!flip; for(let r=0;r<rows;r++){ const y=ARENA.y+12+r*((ARENA.h-24)/(rows-1)); bullets.push({x:left?ARENA.x-24:ARENA.x+ARENA.w+24,y, vx:(left?1:-1)*vx, vy:0, r:3, col, dmg:6}); } }},done(){return t>=dur}}; }
function phaseRing(dur=3,col='#fff',spd=260,n=18,rate=0.4){ let t=0,a=0; return {enter(){t=0;a=0},update(dt){t+=dt;a+=dt; while(a>=rate){a-=rate; const C={x:ARENA.x+ARENA.w/2,y:ARENA.y+ARENA.h/2}; for(let k=0;k<n;k++){ const ang=k/n*Math.PI*2; bullets.push({x:C.x,y:C.y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,r:3,col,dmg:6}); } }},done(){return t>=dur}}; }
function phaseSpiral(dur=3,col='#fff',spd=300,rate=0.04){ let t=0,a=0; return {enter(){t=0;a=0},update(dt){t+=dt;a+=dt; while(a>=rate){a-=rate; const C={x:ARENA.x+ARENA.w/2,y:ARENA.y+ARENA.h/2}; const ang=t*2.6; bullets.push({x:C.x,y:C.y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,r:3,col,dmg:6}); }},done(){return t>=dur}}; }
function phaseHoming(dur=3,col='#fff',spd=280,rate=0.36){ let t=0,a=0; return {enter(){t=0;a=0},update(dt){t+=dt;a+=dt; while(a>=rate){a-=rate; const x=ARENA.x+ARENA.w*0.25; const dx=HEART.x-x, dy=HEART.y-(ARENA.y-12), L=Math.hypot(dx,dy)||1; bullets.push({x,y:ARENA.y-12,vx:dx/L*spd,vy:dy/L*spd,r:4,col,dmg:7}); }},done(){return t>=dur}}; }

/* Boss roster (2) */
function B(name,hp,draw,bg,intro,lines,attacks,isAdmin=false){ return {name,hpMax:hp,hp:hp,draw,bg,intro,lines,attacks,isAdmin}; }
const BOSSES=[
  B('Solar Fang', 360, drawSolar, bgSolar,
    ["The sun bows to no one.","Your shadow stretches long."],
    ["The air shimmers with heat.","Solar Fang glares silently."],
    ()=>[
      phaseRain(2.2,'#fff3b8',280,12,0.09),
      phaseWall(2.2,'#ffe9a0',280,8,0.48),
      phaseRing(2.2,'#ffd166',260,16,0.46),
      phaseSpiral(2.2,'#ffd166',300,0.04),
      phaseRain(2.2,'#fff1b6',300,14,0.08)
    ],
    false
  ),
  B('The Cupcake Incident', 800, drawCupcake, bgCandy,
    ["The frosting trembles ominously.","Sprinkles rain like shrapnel."],
    ["Sweet doom.","Sugar crash.","Frosting storm."],
    ()=>[
      phaseRain(2.2,'#ffb7e6',320,16,0.06),
      phaseWall(2.2,'#ff7acb',320,10,0.40),
      phaseHoming(2.2,'#ff3a6b',300,0.35),
      phaseRing(2.2,'#ffc3f3',300,20,0.40),
      phaseSpiral(2.2,'#ff9ad6',320,0.03)
    ],
    true
  )
];

/* Flow */
function setBoss(index=0){
  const src=BOSSES[index]; BOSS={...src}; BOSS.hp=BOSS.hpMax; bossIndex=index;
  bullets.length=0; HEART.hp=HEART.hpMax=60; HEART.i=0; centerHeart();
  attackSeq=BOSS.attacks(); attackIx=0; attack=null;
  turn='player'; showArena=false; arenaEl.style.display='none';
  bossName.textContent=BOSS.name; updateBossBar(); updatePlayerBar();
  say(BOSS.intro.join('\n')+"\n\nControls:\nZ/Enter/Space: Fight • A: Act • I: Item • M: Mercy\nArrows/WASD: move during attacks • ESC: Restart • B: Switch boss • T: Run tests");
}
function startAttack(){
  bullets.length=0; showArena=true; arenaEl.style.display='block'; hideSay(); uiBar.style.opacity='0.6';
  attack=attackSeq[attackIx]; attack.enter&&attack.enter(); attackIx=(attackIx+1)%attackSeq.length; turn='enemy';
}
function endAttack(){
  showArena=false; arenaEl.style.display='none'; uiBar.style.opacity='1'; turn='player';
  say(BOSS.lines[Math.floor(Math.random()*BOSS.lines.length)]||'...'); attack=null;
}
function win(){ say(`You defeated ${BOSS.name}.`); setTimeout(()=>setBoss(bossIndex),900); }
function lose(){ say('You fall. The hall dims.'); setTimeout(()=>setBoss(bossIndex),900); }

/* Input */
const held=new Set();
document.addEventListener('keydown',e=>{
  if(e.key==='Escape'){ setBoss(bossIndex); return; }
  if(e.key==='b' || e.key==='B'){ setBoss((bossIndex+1)%BOSSES.length); return; }
  if(e.key==='t' || e.key==='T'){ runTests(); return; }
  if(turn==='player'){
    if(['z','Z','Enter',' '].includes(e.key)) onAction('FIGHT');
    else if(e.key==='a'||e.key==='A') onAction('ACT');
    else if(e.key==='i'||e.key==='I') onAction('ITEM');
    else if(e.key==='m'||e.key==='M') onAction('MERCY');
  } else {
    if(['ArrowLeft','a','A'].includes(e.key)) held.add('left');
    if(['ArrowRight','d','D'].includes(e.key)) held.add('right');
    if(['ArrowUp','w','W'].includes(e.key)) held.add('up');
    if(['ArrowDown','s','S'].includes(e.key)) held.add('down');
  }
});
document.addEventListener('keyup',e=>{
  if(['ArrowLeft','a','A'].includes(e.key)) held.delete('left');
  if(['ArrowRight','d','D'].includes(e.key)) held.delete('right');
  if(['ArrowUp','w','W'].includes(e.key)) held.delete('up');
  if(['ArrowDown','s','S'].includes(e.key)) held.delete('down');
});
uiBar.addEventListener('click',e=>{
  const b=e.target.closest('.btn'); if(!b) return; onAction(b.dataset.act);
});

function onAction(act){
  if(turn!=='player') return;
  if(act==='FIGHT'){
    const dealt=24; BOSS.hp=Math.max(0,BOSS.hp-dealt); updateBossBar(); say(`You strike ${BOSS.name}.`);
    if(BOSS.hp<=0) win(); else setTimeout(()=>startAttack(),140);
  } else if(act==='ACT'){
    say(`You steady yourself.`); setTimeout(()=>startAttack(),140);
  } else if(act==='ITEM'){
    HEART.hp=Math.min(HEART.hpMax, HEART.hp+12); updatePlayerBar(); say(`You used a petal. +12 HP`); setTimeout(()=>startAttack(),140);
  } else if(act==='MERCY'){
    say(`${BOSS.name} isn't ready to be spared.`);
  }
}

/* Movement / bullets / collide */
function moveHeart(dt){
  if(turn!=='enemy') return;
  let dx=(held.has('left')?-1:0)+(held.has('right')?1:0);
  let dy=(held.has('up')?-1:0)+(held.has('down')?1:0);
  const L=Math.hypot(dx,dy)||1;
  HEART.x=Math.max(ARENA.x+HEART.r,Math.min(ARENA.x+ARENA.w-HEART.r, HEART.x+dx/L*HEART.sp*dt));
  HEART.y=Math.max(ARENA.y+HEART.r,Math.min(ARENA.y+ARENA.h-HEART.r, HEART.y+dy/L*HEART.sp*dt));
}
function updateBullets(dt){
  for(const b of bullets){ b.x+=b.vx*dt; b.y+=b.vy*dt; }
  const m=200; bullets=bullets.filter(b=> b.x>ARENA.x-m && b.x<ARENA.x+ARENA.w+m && b.y>ARENA.y-m && b.y<ARENA.y+ARENA.h+m);
}
function collide(){
  if(HEART.i>0 || turn!=='enemy') return;
  for(const b of bullets){
    const dx=b.x-HEART.x, dy=b.y-HEART.y, rr=(b.r||4)+HEART.r;
    if(dx*dx+dy*dy<=rr*rr){
      HEART.hp=Math.max(0, HEART.hp-(b.dmg||3)); updatePlayerBar(); HEART.i=0.85;
      if(HEART.hp<=0) lose();
      break;
    }
  }
}

/* Render + loop */
function render(){
  if(BOSS){ BOSS.bg(time); BOSS.draw(time); } else { ctx.fillStyle='#09090f'; ctx.fillRect(0,0,960,720); }
  if(showArena){
    ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.strokeRect(ARENA.x,ARENA.y,ARENA.w,ARENA.h);
    for(const b of bullets){ ctx.fillStyle=b.col||'#fff'; ctx.beginPath(); ctx.arc(b.x,b.y,b.r||3,0,Math.PI*2); ctx.fill(); }
    drawSOUL(HEART.x,HEART.y,4,'#ff0000');
  }
}
function loop(now){
  const dt=Math.min(0.033, Math.max(0,(now-last)/1000)); last=now; time+=dt;
  if(HEART.i>0) HEART.i=Math.max(0, HEART.i-dt);
  if(turn==='enemy'){
    moveHeart(dt);
    attack && attack.update && attack.update(dt);
    updateBullets(dt);
    collide();
    if(attack && attack.done && attack.done()) endAttack();
  }
  render();
  requestAnimationFrame(loop);
}

/* Self-tests (press T) */
async function runTests(){
  const log=[]; let pass=true;
  function check(cond,msg){ if(cond){ log.push('✔ '+msg); } else { log.push('✘ '+msg); pass=false; } }
  function show(){ testEl.style.display='block'; testEl.className=pass?'pass':'fail'; testEl.textContent=(pass?'All tests passed\n\n':'Tests failed\n\n')+log.join('\n'); if(pass) setTimeout(()=>testEl.style.display='none',2500); }

  // Start solar
  setBoss(0);
  check(BOSS && BOSS.name==='Solar Fang','Boss loads');
  check(BOSS.hp===BOSS.hpMax && BOSS.hp>0,'Boss HP initialized');
  check(HEART.hp===HEART.hpMax && HEART.hp>0,'Player HP initialized');
  updateBossBar(); updatePlayerBar();
  check((parseFloat(bossFill.style.width)||0)>=0,'Boss bar width set');
  check((parseFloat(hpFill.style.width)||0)>=0,'Player bar width set');

  // FIGHT action reduces HP
  const hpBefore=BOSS.hp; onAction('FIGHT');
  check(BOSS.hp<hpBefore,'FIGHT reduces boss HP');
  // Attack started
  setTimeout(()=>{
    check(showArena===true && arenaEl.style.display==='block','Arena visible during attack');

    // Spawn bullets
    for(let i=0;i<60;i++){ attack.update(1/60); updateBullets(1/60); }
    check(bullets.length>0,'Bullets spawned');

    // Bounds clamp
    HEART.x=ARENA.x-999; HEART.y=ARENA.y-999; moveHeart(0);
    check(HEART.x>=ARENA.x+HEART.r && HEART.y>=ARENA.y+HEART.r,'Heart clamped to arena');

    // Collision deals damage
    const hpP=HEART.hp; bullets.push({x:HEART.x,y:HEART.y,vx:0,vy:0,r:6,dmg:3}); collide();
    check(HEART.hp<hpP,'Collision reduces player HP');

    // Phase ends back to player
    while(!attack.done()) attack.update(0.25);
    endAttack();
    check(turn==='player' && !showArena,'Turn returns to player');

    // ITEM heals
    const hpBeforeItem=HEART.hp; onAction('ITEM');
    check(HEART.hp>hpBeforeItem,'ITEM heals +12');

    // MERCY message
    onAction('MERCY'); check(bubbleText.textContent.toLowerCase().includes("isn't ready"),'MERCY shows message');

    // ACT starts attack
    onAction('ACT');
    setTimeout(()=>{
      check(turn==='enemy','ACT starts an attack');

      // Switch to Cupcake and verify loads
      setBoss(1);
      check(BOSS.name==='The Cupcake Incident','Cupcake loads');
      // Background draw sanity (just call render once)
      render(); check(true,'Candy background rendered (visual)');

      // Win flow
      BOSS.hp=24; updateBossBar(); onAction('FIGHT');
      setTimeout(()=>{
        check(bubbleText.textContent.toLowerCase().includes('defeated'),'Win shows message');
        show();
      },200);
    },160);
  },160);
}

/* Boot */
setBoss(0);
requestAnimationFrame(loop);
</script>
</body>
</html>
